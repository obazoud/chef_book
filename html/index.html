<!DOCTYPE html> <html> <head> <meta charset=utf-8> <meta name=generator content=pandoc> <meta name=viewport content="width=device-width, initial-scale=1.0, user-scalable=yes"> <meta name=author content="Alexey Vasiliev aka leopard and Contributors"> <title>Cooking Infrastructure by Chef</title> <style>code{white-space: pre;}</style> <!--[if lt IE 9]><script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script><![endif]--> </head> <body> <header> <h1 class=title>Cooking Infrastructure by Chef</h1> <h2 class=author>Alexey Vasiliev aka leopard and <a href="https://github.com/le0pard/chef_book/graphs/contributors">Contributors</a></h2> <h3 class=date>Creative Commons Attribution-Noncommercial 4.0 International<br/>2014</h3> </header> <nav id=TOC> <ul> <li><a href="#introduction">Introduction</a></li> <li><a href="#so-what-is-chef">So, what is Chef?</a><ul> <li><a href="#sec:what-principles">What are the core principles?</a><ul> <li><a href="#idempotence">Idempotence</a></li> <li><a href="#thick-clients-thin-server">Thick Clients, Thin Server</a></li> <li><a href="#order-matters">Order Matters</a></li> </ul></li> <li><a href="#sec:what-benefits">Why you should use Chef?</a></li> <li><a href="#what-doesnt-chef-do">What doesn’t Chef do?</a></li> <li><a href="#summary">Summary</a></li> </ul></li> <li><a href="#chef-solo">Chef Solo</a><ul> <li><a href="#sec:solo-required">Required software</a><ul> <li><a href="#rubygems-and-bundler">Rubygems and bundler</a></li> <li><a href="#knife-solo">Knife-solo</a></li> <li><a href="#berkshelf">Berkshelf</a></li> </ul></li> <li><a href="#sec:solo-kitchen">Creation of kitchen (chef-repo)</a></li> <li><a href="#sec:solo-chef-folder">.Chef folder</a></li> <li><a href="#sec:solo-berkshelf">Vendor cookbooks and berkshelf</a></li> <li><a href="#sec:solo-node">Defining nodes</a></li> <li><a href="#sec:solo-vagrant">Vagrant</a></li> <li><a href="#sec:solo-idempotence">Idempotence</a></li> <li><a href="#sec:solo-role">Defining roles</a></li> <li><a href="#sec:solo-attributes">Attributes</a></li> <li><a href="#sec:solo-environment">Defining environments</a></li> <li><a href="#sec:solo-data-bag">Defining data bags</a></li> <li><a href="#summary-1">Summary</a></li> </ul></li> <li><a href="#chef-server">Chef Server</a><ul> <li><a href="#sec:server-installation">Installation</a></li> <li><a href="#sec:server-knife">Knife</a></li> <li><a href="#sec:server-node">Bootstrap first node</a><ul> <li><a href="#node-in-vagrant">Node in Vagrant</a></li> </ul></li> <li><a href="#sec:server-attributes">Attributes</a><ul> <li><a href="#attribute-types">Attribute Types</a></li> <li><a href="#automatic-ohai">Automatic (Ohai)</a></li> <li><a href="#attribute-precedence">Attribute Precedence</a></li> </ul></li> <li><a href="#sec:server-role">Role</a></li> <li><a href="#sec:server-environment">Environment</a></li> <li><a href="#sec:server-knife-ssh">Knife ssh</a><ul> <li><a href="#chef-client-cookbook">Chef-client cookbook</a></li> </ul></li> <li><a href="#sec:server-data-bags">Data bags</a></li> <li><a href="#summary-2">Summary</a></li> </ul></li> <li><a href="#writing-cookbooks">Writing Cookbooks</a><ul> <li><a href="#sec:cookbook-files">Cookbook file organization</a></li> <li><a href="#sec:cookbook-metadata">Metadata</a></li> <li><a href="#sec:cookbook-resources">Resources and Providers</a><ul> <li><a href="#bash">Bash</a></li> <li><a href="#cron">Cron</a></li> <li><a href="#directory">Directory</a></li> <li><a href="#git">Git</a></li> <li><a href="#link">Link</a></li> <li><a href="#cookbook_file">Cookbook_file</a></li> <li><a href="#template">Template</a></li> <li><a href="#script">Script</a></li> <li><a href="#user">User</a></li> <li><a href="#deploy">Deploy</a></li> </ul></li> <li><a href="#sec:cookbook-recipes">Recipes</a><ul> <li><a href="#assign-dependencies">Assign Dependencies</a></li> <li><a href="#create-exceptions">Create Exceptions</a></li> <li><a href="#include-recipes">Include Recipes</a></li> <li><a href="#reload-attributes">Reload Attributes</a></li> <li><a href="#accessor-methods">Accessor Methods</a></li> </ul></li> <li><a href="#sec:cookbook-attributes">Attributes</a></li> <li><a href="#sec:cookbook-templates">Templates</a><ul> <li><a href="#file-specificity">File Specificity</a></li> <li><a href="#partial-templates">Partial Templates</a></li> </ul></li> <li><a href="#sec:cookbook-lwrp">LWRPs</a><ul> <li><a href="#resources">Resources</a></li> <li><a href="#providers">Providers</a></li> <li><a href="#dsl-methods">DSL Methods</a></li> <li><a href="#using-lwrp">Using LWRP</a></li> </ul></li> <li><a href="#sec:cookbook-hwrp">HWRPs</a><ul> <li><a href="#hwrps-and-lwrps">HWRPs and LWRPS</a></li> <li><a href="#example">Example</a></li> </ul></li> <li><a href="#sec:cookbook-definitions">Definitions</a><ul> <li><a href="#example-1">Example</a></li> </ul></li> <li><a href="#sec:cookbook-ohai">Ohai</a><ul> <li><a href="#example-2">Example</a></li> </ul></li> <li><a href="#summary-3">Summary</a></li> </ul></li> <li><a href="#testing-cookbooks">Testing Cookbooks</a><ul> <li><a href="#sec:testing-types">Test Types</a><ul> <li><a href="#unit-testing">Unit Testing</a></li> <li><a href="#integration-testing">Integration Testing</a></li> <li><a href="#acceptance-testing">Acceptance Testing</a></li> </ul></li> <li><a href="#sec:testing-chefspec">ChefSpec</a><ul> <li><a href="#installing">Installing</a></li> <li><a href="#testing">Testing</a></li> </ul></li> <li><a href="#sec:testing-fauxhai">Fauxhai</a><ul> <li><a href="#testing-1">Testing</a></li> </ul></li> <li><a href="#sec:testing-test-kitchen">Test Kitchen</a><ul> <li><a href="#installing-1">Installing</a></li> <li><a href="#running-kitchen-converge">Running Kitchen Converge</a></li> <li><a href="#manually-verifying">Manually Verifying</a></li> <li><a href="#writing-a-test">Writing a Test</a></li> <li><a href="#running-kitchen-test">Running Kitchen Test</a></li> <li><a href="#adding-a-platform">Adding a Platform</a></li> <li><a href="#fixing-converge">Fixing Converge</a></li> <li><a href="#adding-a-suite">Adding a Suite</a></li> <li><a href="#writing-a-server-test">Writing a Server Test</a></li> </ul></li> <li><a href="#sec:testing-chef-zero">Chef Zero</a><ul> <li><a href="#installing-2">Installing</a></li> <li><a href="#using-with-chefspec">Using with ChefSpec</a></li> <li><a href="#using-with-test-kitchen">Using with Test Kitchen</a></li> </ul></li> <li><a href="#sec:testing-minitest">Minitest</a><ul> <li><a href="#test-kitchen">Test Kitchen</a></li> <li><a href="#minitest-chef-handler">Minitest Chef Handler</a></li> </ul></li> <li><a href="#sec:testing-cucumber-spec">Cucumber</a><ul> <li><a href="#example-4">Example</a></li> </ul></li> <li><a href="#sec:testing-analysis-and-linting">Static Analysis and Linting Tools</a><ul> <li><a href="#foodcritic">Foodcritic</a></li> <li><a href="#rubocop">RuboCop</a></li> <li><a href="#strainer">Strainer</a></li> </ul></li> <li><a href="#summary-4">Summary</a></li> </ul></li> <li><a href="#tips-and-tricks">Tips and Tricks</a><ul> <li><a href="#sec:tat-wrapper-cookbook">Wrapper cookbook</a><ul> <li><a href="#codifying-standards-in-your-organization">Codifying Standards in Your Organization</a></li> <li><a href="#modifying-upstream-cookbook-behavior">Modifying Upstream Cookbook Behavior</a></li> <li><a href="#advanced-upstream-cookbook-modification">Advanced Upstream Cookbook Modification</a></li> <li><a href="#summary-5">Summary</a></li> </ul></li> <li><a href="#sec:tat-knife-plugins">Knife Plugins</a><ul> <li><a href="#examples">Examples</a></li> </ul></li> <li><a href="#sec:tat-chef-metal">Chef Metal</a><ul> <li><a href="#examples-1">Examples</a></li> </ul></li> <li><a href="#sec:tat-chef-sugar">Chef Sugar</a><ul> <li><a href="#usage">Usage</a></li> </ul></li> <li><a href="#summary-6">Summary</a></li> </ul></li> </ul> </nav> <h1 id=introduction>Introduction</h1> <p>Chef is a configuration management and automation platform from <a href="//www.getchef.com/">Chef</a>. Chef helps you describe your infrastructure with code. Because your infrastructure is managed with code, it can be automated, tested and reproduced with ease.</p> <h1 id=so-what-is-chef>So, what is Chef?</h1> <p>[fig:chef<sub>l</sub>ogo]</p> <p><a href="//www.getchef.com/">Chef</a> is a configuration management tool written in Ruby and Erlang. It uses a pure-Ruby, domain-specific language (DSL) for writing system configuration «recipes». Chef is used to streamline the task of configuring and maintaining a company’s servers, and can integrate with cloud-based platforms such as Rackspace and Amazon EC2 to automatically provision and configure new machines.</p> <p>The user writes «recipes» that describe how Chef manages server applications (such as Apache, MySQL, or Hadoop) and how they are to be configured. These recipes describe a series of resources that should be in a particular state: packages that should be installed, services that should be running, or files that should be written. Chef makes sure each resource is properly configured and corrects any resources that are not in the desired state.</p> <p>Traditionally, Chef is used to manage GNU/Linux but later versions support running on Windows as well.</p> <h2 id="sec:what-principles">What are the core principles?</h2> <h3 id=idempotence>Idempotence</h3> <p>A recipe can run multiple times on the same system and the results will always be identical. A resource is defined in a recipe, which then defines the actions to be performed on the system. The chef-client ensures that actions are not performed if the resources have not changed and that any action that is performed is done the same way each time. If a recipe is re-run and nothing has changed, then the chef-client will not do anything.</p> <h3 id=thick-clients-thin-server>Thick Clients, Thin Server</h3> <p>Chef does as much work as possible on the node and as little as possible on the server. A chef-client runs on each node and it only interacts with the server when it needs to. The server is designed to distribute the data to each node easily, including all cookbooks, recipes, templates, files, and so on. The server also retains a copy of the state of the node at the conclusion of every chef-client run. This approach ensures that the actual work needed to configure each node in your infrastructure is distributed across the organization, rather than centralized on smaller set of configuration management servers.</p> <h3 id=order-matters>Order Matters</h3> <p>When the chef-client configures each node in the system, the order in which that configuration occurs is very important. For example, if Apache is not installed, then it cannot be configured and the daemon cannot be started. Configuration management tools have struggled with this problem for a long time. For each node a list of recipes is applied. Within a recipe, resources are applied in the order in which they are listed. At any point in a recipe other recipes may be included, which assures that all resources are applied. The chef-client will never apply the same recipe twice. Dependencies are only applied at the recipe level (and never the resource level). This means that dependencies can be tracked between high-level concepts like «I need to install Apache before I can start my Django application!» It also means that given the same set of cookbooks, the chef-client will always execute resources in the same exact order.</p> <h2 id="sec:what-benefits">Why you should use Chef?</h2> <p>There are several reasons for using Chef:</p> <ul> <li><p><strong>Efficiency:</strong> It’s more effective to use Chef, which will contain all your servers configuration in one place</p></li> <li><p><strong>Scalability:</strong> Do you need to scale your app? Split your server into several cloud servers, by using environments, roles and nodes</p></li> <li><p><strong>Reusing and Save money:</strong> No need to install the same software 10 times for your application on the server. Just create a new node in Chef and after several minutes you will have configured the instance</p></li> <li><p><strong>Documentation:</strong> Chef is also documentation for your cloud, because Chef recipes contain all the configuration information for your environment</p></li> </ul> <p>And of course the main point is shown on picture [fig:automate-all-the-things].</p> <p>[fig:automate-all-the-things]</p> <h2 id=what-doesnt-chef-do>What doesn’t Chef do?</h2> <ul> <li><p>«Magically» configure your server</p></li> <li><p>Blindly reuse cookbooks and recipes</p></li> <li><p>Monitor your servers or software</p></li> <li><p>Undoing concept</p></li> </ul> <h2 id=summary>Summary</h2> <p>The key underlying principle of Chef is that you (the user) knows best about what your environment is, what it should do, and how it should be maintained. The chef-client is designed to not make assumptions about any of those things. Only the individuals on the ground — that’s you and your team—understand the technical problems and what is required to solve them. Only your team can understand the human problems (skill levels, audit trails, and other internal issues) that are unique to your organization and whether any single technical solution is viable.</p> <p>The idea that you know best about what should happen in your organization goes hand-in-hand with the notion that you still need help keeping it all running. It is rare that a single individual knows everything about a very complex problem, let alone knows all of the steps that may be required to solve them. The same is true with tools. Chef provides help with infrastructure management, and can help solve very complicated problems. Chef also has a large community of users who have a lot of experience solving a lot of very complex problems. That community can provide knowledge and support in areas that your organization may not have and (along with Chef) can help your organization solve any complex problem.</p> <h1 id=chef-solo>Chef Solo</h1> <p>Chef Solo is simple way to begin working with Chef. It is an open source version of the chef-client that allows using cookbooks with nodes without requiring access to a server. Chef Solo runs locally and requires that a cookbook (and any of its dependencies) be on the same physical disk as the node. It is a limited-functionality version of the chef-client and does not support the following:</p> <ul> <li><p>Node data storage</p></li> <li><p>Search indexes</p></li> <li><p>Centralized distribution of cookbooks</p></li> <li><p>A centralized API that interacts with and integrates infrastructure components</p></li> <li><p>Authentication or authorization</p></li> <li><p>Persistent attributes</p></li> </ul> <p>We will learn Chef Solo by practical examples in this chapter.</p> <h2 id="sec:solo-required">Required software</h2> <p>To get started working with Chef, you need to install the required software:</p> <ul> <li><p><a href="https://www.virtualbox.org/">Virtual Box</a> to provide a local virtual machine to manage using Chef</p></li> <li><p><a href="//www.vagrantup.com/">Vagrant</a> to give a command line interface to manage Virtual Box</p></li> <li><p><a href="//git-scm.com/">Git</a> to revision Chef code and Recipes</p></li> <li><p><a href="https://www.ruby-lang.org">Ruby</a> (since Chef runs on it). For simple installation of it you can use the <a href="https://rvm.io/">RVM</a> or <a href="https://github.com/sstephenson/rbenv">Rbenv</a></p></li> </ul> <p>To get started with Chef, we need to create chef-repo (kitchen), which will contain all the data for a chef client(s). For example, I’ll create a directory «my-cloud», which will contain a chef-repo (kitchen). In this directory I create a file «Gemfile» with such content:</p> <pre><code>source &quot;https://rubygems.org&quot;

gem &#39;knife-solo&#39;
gem &#39;berkshelf&#39;</code></pre> <p>and run command <code>bundle</code> in terminal. As a result, by using <a href="//bundler.io/">bundler</a>, we install any required rubygems.</p> <h3 id=rubygems-and-bundler>Rubygems and bundler</h3> <p><a href="//rubygems.org/">RubyGems</a> is a package manager for the Ruby programming language that provides a standard format for distributing Ruby programs and libraries (in a self-contained format called a «gem»), a tool designed to easily manage the installation of gems, and a server for distributing them. It is analogous to EasyInstall for the Python programming language.</p> <p><a href="//bundler.io/">Bundler</a> provides a consistent environment for Ruby projects by tracking and installing the exact gems and versions that are needed. Bundler is an exit from dependency hell, and ensures that the gems you need are present in development, staging, and production.</p> <p>But why do we need these rubygems?</p> <h3 id=knife-solo>Knife-solo</h3> <p>Knife is a command-line tool that provides an interface between a local chef-repo and the Chef server. But for Chef Solo is better to install the <a href="//matschaffer.github.io/knife-solo/">knife-solo</a> plugin. It will install knife as dependency and adds 5 subcommands to knife tool:</p> <ul> <li><p><code>knife solo init</code> is used to create a new directory structure (i.e. kitchen) that fits with Chef’s standard structure and can be used to build and store recipes</p></li> <li><p><code>knife solo prepare</code> installs Chef on a given host. It’s structured to auto-detect the target OS and change the installation process accordingly</p></li> <li><p><code>knife solo cook</code> uploads the current kitchen to the target host and runs chef-solo on that host</p></li> <li><p><code>knife solo bootstrap</code> combines the two previous ones (prepare and cook)</p></li> <li><p><code>knife solo clean</code> removes the uploaded kitchen from the target host</p></li> </ul> <p>Knife-solo also integrates with <a href="//berkshelf.com/">Berkshelf</a> and <a href="https://github.com/applicationsonline/librarian-chef">Librarian-Chef</a>.</p> <h3 id=berkshelf>Berkshelf</h3> <p><a href="//berkshelf.com/">Berkshelf</a> is used as well as the bundler for rubygems - it manages cookbooks and their dependencies. Also, there is <a href="https://github.com/applicationsonline/librarian-chef">librarian-chef</a>, which performs a similar function. I prefer to use berkshelf, because it has more features and integrations.</p> <h2 id="sec:solo-kitchen">Creation of kitchen (chef-repo)</h2> <p>Working with Chef Solo starts with creating kitchen (chef-repo). The kitchen is located on a workstation (the location from which most users will do most of their work, ie. your computer) and should be synchronized with a version control system. To create a kitchen use knife-solo rubygems:</p> <pre><code>$ cd my-cloud
$ knife solo init .
WARNING: No knife configuration file found
Creating kitchen...
Creating knife.rb in kitchen...
Creating cupboards...
Setting up Berkshelf...
$ ls -o
total 32
-rw-r--r--  1 leo    14 Dec 14 00:36 Berksfile
-rw-r--r--@ 1 leo    63 Dec 14 00:36 Gemfile
-rw-r--r--  1 leo  4427 Dec 14 00:36 Gemfile.lock
drwxr-xr-x  3 leo   102 Dec 14 00:36 cookbooks
drwxr-xr-x  3 leo   102 Dec 14 00:36 data_bags
drwxr-xr-x  3 leo   102 Dec 14 00:36 environments
drwxr-xr-x  3 leo   102 Dec 14 00:36 nodes
drwxr-xr-x  3 leo   102 Dec 14 00:36 roles
drwxr-xr-x  3 leo   102 Dec 14 00:36 site-cookbooks</code></pre> <p>Let’s consider the directory structure:</p> <ul> <li><p><code>.chef</code> - a hidden directory that is used to store .pem files and the knife.rb file</p></li> <li><p><code>cookbooks</code> - directory for Chef cookbooks. This directory will be used for vendor cookbooks, that will be installed with the help of berkshelf</p></li> <li><p><code>data_bags</code> - directory for Chef Data Bags</p></li> <li><p><code>environments</code> - directory for Chef environments</p></li> <li><p><code>nodes</code> - directory for Chef nodes</p></li> <li><p><code>roles</code> - directory for Chef roles</p></li> <li><p><code>site-cookbooks</code> - directory for your custom Chef cookbooks</p></li> <li><p><code>Berksfile</code> - file contains a list of sources identifying which cookbooks to retrieve and where to get them for berkshelf (like Gemfile for rubygems)</p></li> </ul> <p>«Cookbooks» directory added into «.gitignore», because it contains only vendor cookbooks. Vendor cookbook data will not be modified, so there is no reason to keep them in VCS (git, mercurial, etc).</p> <h2 id="sec:solo-chef-folder">.Chef folder</h2> <p>The «.chef» directory that is used to store .pem files and the knife.rb file.</p> <p>For Chef Solo in this directory mostly contained only knife.rb file. A knife.rb file is used to specify the chef-repo-specific configuration details for Knife. This file is the default configuration file and is loaded every time this executable is run. The configuration file is located at: <code>~/.chef/knife.rb</code>. If a knife.rb file is present in the <code>.chef/knife.rb</code> directory in the chef-repo, the settings contained within that file will override the default configuration settings.</p> <p>In example, knife.rb have such content:</p> <pre><code>cookbook_path    [&quot;cookbooks&quot;, &quot;site-cookbooks&quot;]
node_path        &quot;nodes&quot;
role_path        &quot;roles&quot;
environment_path &quot;environments&quot;
data_bag_path    &quot;data_bags&quot;
#encrypted_data_bag_secret &quot;data_bag_key&quot;

knife[:berkshelf_path] = &quot;cookbooks&quot;</code></pre> <p>Let’s look at the meaning of these options:</p> <ul> <li><p><code>cookbook_path</code> - the sub-directory for cookbooks on the chef-client</p></li> <li><p><code>node_path</code> - the sub-directory for nodes on the chef-client</p></li> <li><p><code>role_path</code> - the sub-directory for roles on the chef-client</p></li> <li><p><code>environment_path</code> - the sub-directory for environments on the chef-client</p></li> <li><p><code>data_bag_path</code> - the sub-directory for Data Bags on the chef-client</p></li> <li><p><code>knife[:berkshelf_path]</code> - as you remember, knife-solo have integration with Berkshelf and Librarian-Chef. By this option we set directory in which knife will install vendor cookbooks from Berksfile before «cook» node</p></li> </ul> <h2 id="sec:solo-berkshelf">Vendor cookbooks and berkshelf</h2> <p>Suppose, that our task to install Apache2 on node. For this purpose we can use vendor cookbook through berkshelf. Huge amount cookbooks you can find at <a href="https://supermarket.getchef.com/cookbooks-directory">Chef community website</a>. To install Apache2 cookbook we need add it to Berksfile:</p> <pre><code>source &quot;http://api.berkshelf.com&quot;

cookbook &#39;apache2&#39;</code></pre> <p>After running the command <code>berks install</code> this cookbook will be installed with dependencies.</p> <pre><code>$ berks install
Using apache2 (1.7.0)</code></pre> <p>By default, you will not find this cookbook in «cookbooks» directory. Berkshelf install cookbooks in « /.berkshelf» directory (to avoid duplication of cookbooks, if you have several chef-repo). To install it in special path you can use <code>vendor</code> command:</p> <pre><code>$ berks vendor cookbooks
Using apache2 (1.7.0)
$ ls cookbooks
apache2</code></pre> <p>Option <code>knife[:berkshelf_path]</code> in knife.rb file set to install our cookbooks into cookbooks directory. In this case no need to run <code>berks install --path cookbooks</code> each time, when you need «cook» a node - knife-solo will do it automatically.</p> <p>Now we can start to work with a nodes.</p> <h2 id="sec:solo-node">Defining nodes</h2> <p>Node itself represent any physical, virtual, or cloud machine. In most cases number of nodes in kitchen equal of number of machines in your cloud. To install apache2 to the correct server, we need to create a file in the nodes folder. Basically, this file is named as machine domain. For example, I attach to the machine domain «web1.example.com» and create node for it:</p> <pre><code>{
  &quot;run_list&quot;: []
}</code></pre> <p>Node file should contain valid JSON document. Main key in this json is <code>run_list</code>. This key contain array of recipes and roles, which should be executed on machine. It always executed in the same order as listed in this key. As you can see right now <code>run_list</code> is empty. To install apache2 you need to add the recipe in this array. This information can be found in README of cookbook (if this vendor cookbook well written), in metadata.rb or just open directory recipes - the name of the file will mean recipe name. <code>default.rb</code> file mean a recipe that will be executed when you call the cookbook in <code>run_list</code> without designation of recipe. Examples:</p> <pre><code>{
  &quot;run_list&quot;: [
    &quot;recipe[apache2]&quot;
  ]
}</code></pre> <p>This <code>run_list</code> will execute default recipe from apache2 cookbook.</p> <p>Now we are ready to test our kitchen.</p> <h2 id="sec:solo-vagrant">Vagrant</h2> <p>For testing our chef kitchen in most cases we are using Vagrant. So what is Vagrant?</p> <p><a href="//www.vagrantup.com/">Vagrant</a> is free and open-source software for creating and configuring virtual development environments. It can be considered a wrapper around VirtualBox and configuration management software such as Chef. Since version 1.1, Vagrant is no longer tied to VirtualBox and also works with other virtualization software such as VMware and Amazon EC2.</p> <p>Instead of building a virtual machine from scratch, which would be a slow and tedious process, Vagrant uses a base image to quickly clone a virtual machine. These base images are known as boxes in Vagrant, and specifying the box to use for your Vagrant environment is always the first step after creating a new Vagrantfile. For testing will be used Ubuntu 12.04 LTS 64-bit (precise64 box).</p> <pre><code>$ vagrant box add precise64 http://files.vagrantup.com/precise64.box</code></pre> <p>More boxes you can find on <a href="//www.vagrantbox.es/">Vagrantbox.es</a> or <a href="https://vagrantcloud.com/">Vagrant Cloud</a>.</p> <p>The first step for any project to use Vagrant is to configure Vagrant using a Vagrantfile. We should execute <code>vagrant init precise64</code> inside kitchen directory:</p> <pre><code>$ vagrant init precise64
A `Vagrantfile` has been placed in this directory. You are now
ready to `vagrant up` your first virtual environment! Please read
the comments in the Vagrantfile as well as documentation on
`vagrantup.com` for more information on using Vagrant.</code></pre> <p>By default, Vagrantfile have such content:</p> <pre><code># -*- mode: ruby -*-
# vi: set ft=ruby :

# Vagrantfile API/syntax version. Don&#39;t touch unless you know what you&#39;re doing!
VAGRANTFILE_API_VERSION = &quot;2&quot;

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.vm.box = &quot;precise64&quot;
end</code></pre> <p>We can check, what vagrant is working fine by command «vagrant up»:</p> <pre><code>$ vagrant up
Bringing machine &#39;default&#39; up with &#39;virtualbox&#39; provider...
[default] Importing base box &#39;precise64&#39;...
[default] Matching MAC address for NAT networking...
[default] Setting the name of the VM...
[default] Clearing any previously set forwarded ports...
[default] Creating shared folders metadata...
[default] Clearing any previously set network interfaces...
[default] Preparing network interfaces based on configuration...
[default] Forwarding ports...
[default] -- 22 =&gt; 2222 (adapter 1)
[default] Booting VM...
[default] Waiting for machine to boot. This may take a few minutes...
[default] Machine booted and ready!
[default] Mounting shared folders...
[default] -- /vagrant</code></pre> <p>After this you can use command <code>vagrant ssh</code> to SSH into a running Vagrant machine and give you access to a shell. Command «vagrant halt» shuts down the running machine Vagrant is managing. <code>vagrant destroy</code> command stops the running machine Vagrant is managing and destroys all resources that were created during the machine creation process.</p> <p>In most cases, your machine will not contain chef client. We should install it before using our kitchen. As you remember, we have knife with command <code>prepare</code>. Let use this command:</p> <pre><code>$ knife solo prepare vagrant@localhost -i ~/.vagrant.d/insecure_private_key -p 2222 -N web1.example.com
Bootstrapping Chef...
--2013-12-27 19:12:56--  https://www.opscode.com/chef/install.sh
Resolving www.opscode.com (www.opscode.com)... 184.106.28.91
...
Installing Chef 11.8.2
installing with dpkg...
Selecting previously unselected package chef.
(Reading database ... 51095 files and directories currently installed.)
Unpacking chef (from .../chef_11.8.2_amd64.deb) ...
Setting up chef (11.8.2-1.ubuntu.12.04) ...
Thank you for installing Chef!</code></pre> <p>We used some options for the <code>knife prepare</code> command. <code>-i</code> option specify ssh key for machine, <code>-N</code> option specify node name (if it different from host name) and <code>-p</code> option specify SSH port. In most cases, this port is 2222, but if you running several machines from vagrant, it will be different. You can read what port is used for SSH by machine from output of command <code>vagrant up</code>. All this credentials used to login by ssh on the node and install chef client.</p> <p>Basically, to run our kitchen on node we are using <code>knife solo cook</code> command:</p> <pre><code>$ knife solo cook vagrant@localhost -i ~/.vagrant.d/insecure_private_key -p 2222 -N web1.example.com
Running Chef on localhost...
Checking Chef version...
Installing Berkshelf cookbooks to &#39;cookbooks&#39;...
Using apache2 (1.7.0)
Uploading the kitchen...
...
 * service[apache2] action start (up to date)
Chef Client finished, 1 resources updated</code></pre> <p>But in Vagrant we can use build in command <code>vagrant provision</code>. This command runs any configured provisioners against the running Vagrant managed machine.</p> <p>Vagrantfile inside use ruby syntax, so we can use Ruby to <a href="//en.wikipedia.org/wiki/Dont_repeat_yourself">DRY</a> our config. We should install chef gem inside vagrant:</p> <pre><code>$ vagrant plugin install chef
Installing the &#39;chef&#39; plugin. This can take a few minutes...
Installed the plugin &#39;chef (11.8.2)&#39;!</code></pre> <p>After this we can use chef gem inside Vagrantfile config:</p> <pre><code># -*- mode: ruby -*-
# vi: set ft=ruby :

require &#39;chef&#39;
require &#39;json&#39;

Chef::Config.from_file(File.join(File.dirname(__FILE__), &#39;.chef&#39;, &#39;knife.rb&#39;))
vagrant_json = JSON.parse(Pathname(__FILE__).dirname.join(&#39;nodes&#39;, (ENV[&#39;NODE&#39;] || &#39;web1.example.com.json&#39;)).read)

# Vagrantfile API/syntax version. Don&#39;t touch unless you know what you&#39;re doing!
VAGRANTFILE_API_VERSION = &quot;2&quot;

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.vm.box = &quot;precise64&quot;

  config.vm.provision :chef_solo do |chef|
    chef.cookbooks_path = Chef::Config[:cookbook_path]
    chef.roles_path = Chef::Config[:role_path]
    chef.data_bags_path = Chef::Config[:data_bag_path]

    chef.environments_path = Chef::Config[:environment_path]
    #chef.environment = ENV[&#39;ENVIRONMENT&#39;] || &#39;development&#39;

    chef.run_list = vagrant_json.delete(&#39;run_list&#39;)
    chef.json = vagrant_json
  end
end</code></pre> <p>Now consider that we have added.</p> <p>On lines 4-5 required chef and json gem. JSON gem is as part of Vagrant and chef gem was installed by previous command <code>vagrant plugin install chef</code>. Further, we load knife.rb file in chef config and parse json from node file «web1.example.com.json». After these manipulations we will have <code>Chef::Config</code> ruby hash with knife configuration and <code>vagrant_json</code> ruby hash with attributes from node.</p> <p>On lines 16-26 defined Chef Solo configuration for Vagrant (<code>environment</code> is commented, because we don’t have it right now, but we will use it later). More information about this you can find in <a href="//docs.vagrantup.com/v2/provisioning/chef_solo.html">vagrant website</a>.</p> <p>Because we changed the Vagrantfile configuration, we need to restart the test node by using <code>vagrant reload</code> command:</p> <pre><code>$ vagrant reload
[default] Attempting graceful shutdown of VM...
...
[default] -- /vagrant
[default] -- /tmp/vagrant-chef-1/chef-solo-3/roles
[default] -- /tmp/vagrant-chef-1/chef-solo-2/cookbooks
[default] -- /tmp/vagrant-chef-1/chef-solo-1/cookbooks
[default] -- /tmp/vagrant-chef-1/chef-solo-4/data_bags
[default] -- /tmp/vagrant-chef-1/chef-solo-5/environments
$ vagrant provision
[default] Running provisioner: chef_solo...
Generating chef JSON and uploading...
Running chef-solo...
stdin: is not a tty
INFO: Forking chef instance to converge...
INFO: *** Chef 11.8.2 ***
...
INFO: service[apache2] restarted
INFO: Chef Run complete in 18.115479422 seconds
INFO: Running report handlers
INFO: Report handlers complete</code></pre> <p>To verify that the apache2 successfully installed into node, we can forward the 80 apache2 port to our machine. To do this, we modify the Vagrantfile:</p> <pre><code>...

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.vm.box = &quot;precise64&quot;
  config.vm.network :forwarded_port, guest: 80, host: 8085 # &lt;== add port forwarding

...</code></pre> <p>And again reload node:</p> <pre><code>$ vagrant reload
...
[default] Preparing network interfaces based on configuration...
[default] Forwarding ports...
[default] -- 22 =&gt; 2222 (adapter 1)
[default] -- 80 =&gt; 8085 (adapter 1)
...</code></pre> <p>Now in any of your browser you can open url <a href="//localhost:8085/">http://localhost:8085/</a> and see 404 page from apache2 server (because we only install it).</p> <h2 id="sec:solo-idempotence">Idempotence</h2> <p>As you read from previous chapter, one of the main idea of Chef is idempotence. It mean, what Chef can safely be run multiple times on the same machine. Once you develop your configuration, your machines will apply the configuration and Chef will only make any changes to the system if the system state does not match the configured state.</p> <p>For now we have machine which contain apache2 running inside it. Let’s run <code>vagrant provision</code> again:</p> <pre><code>$ vagrant provision
[default] Running provisioner: chef_solo...
Generating chef JSON and uploading...
Running chef-solo...
stdin: is not a tty
...
INFO: Chef Run complete in 1.092279021 seconds
...</code></pre> <p>As you can see, chef client did nothing, because configuration of the server the same as in chef kitchen (what is why execution time also so small).</p> <h2 id="sec:solo-role">Defining roles</h2> <p>Roles help classify the same server group. For example, in your project you can have web, queue and db servers. In this case you can create such type of roles, which will include the same attributes and <code>run_list</code> for nodes. Let’s look at an example.</p> <p>For example, in our project we have a web application servers, load balancer server and database server. First we will create roles «web»:</p> <pre><code>{
  &quot;name&quot;: &quot;web&quot;,
  &quot;description&quot;: &quot;The base role for systems that serve web server&quot;,
  &quot;chef_type&quot;: &quot;role&quot;,
  &quot;json_class&quot;: &quot;Chef::Role&quot;,
  &quot;default_attributes&quot;: {
    &quot;apache&quot;: {
      &quot;listen_ports&quot;: [&quot;80&quot;, &quot;443&quot;]
    }
  },
  &quot;run_list&quot;: [
    &quot;recipe[apache2]&quot;
  ]
}</code></pre> <p>Let’s consider current json structure:</p> <ul> <li><p><code>name</code> - a unique name of role. In most cases the same as name of file without extension</p></li> <li><p><code>description</code> - a description of the functionality that is covered by role</p></li> <li><p><code>chef_type</code> - this should always be set to «role»</p></li> <li><p><code>json_class</code> - this should always be set to «Chef::Role»</p></li> <li><p><code>default_attributes</code> - a set of attributes that should be applied to all nodes, assuming the node does not already have a value for the attribute. This is useful for setting global defaults that can then be overridden for specific nodes. If more than one role attempts to set a default value for the same attribute, the last role applied will be the role to set the attribute value. This attribute is optional</p></li> <li><p><code>override_attributes</code> - a set of attributes that should be applied to all nodes, even if the node already has a value for an attribute. This is useful for ensuring that certain attributes always have specific values. If more than one role attempts to set an override value for the same attribute, the last role applied will win. This attribute is optional</p></li> <li><p><code>run_list</code> - a list of recipes and/or roles that will be applied and the order in which those recipes and/or roles will be applied</p></li> <li><p><code>env_run_lists</code> - a list of environments, each specifying a recipe or a role that will be applied to that environment. This attribute is optional</p></li> </ul> <p>To use this role, we can create new node «web2.example.com» with content:</p> <pre><code>{
  &quot;run_list&quot;: [
    &quot;role[web]&quot;
  ]
}</code></pre> <p>And check that everything is working:</p> <pre><code>$ NODE=web2.example.com.json vagrant provision
[default] Running provisioner: chef_solo...
Generating chef JSON and uploading...
Running chef-solo...
stdin: is not a tty
INFO: Forking chef instance to converge...
INFO: *** Chef 11.8.2 ***
INFO: Chef-client pid: 1224
INFO: Setting the run_list to [&quot;role[web]&quot;] from JSON
INFO: Run List is [role[web]]
INFO: Run List expands to [apache2]
...
INFO: Chef Run complete in 1.437157496 seconds
INFO: Running report handlers
INFO: Report handlers complete</code></pre> <p>As you can see, role defined in <code>run_list</code> by command <code>role</code> and role command replaced to run list of this role by chef client. This allow for use use several roles with recipes in the same node. For example, if web and database role should exists on the same node (example: staging environment), you can define <code>run_list</code> in node in such way:</p> <pre><code>{
  &quot;run_list&quot;: [
    &quot;role[web]&quot;,
    &quot;role[db]&quot;
  ]
}</code></pre> <p>BTW, role can contain in run list another roles. For example:</p> <pre><code>{
  &quot;name&quot;: &quot;test&quot;,
  &quot;description&quot;: &quot;The test role, it is not used in kitchen&quot;,
  &quot;chef_type&quot;: &quot;role&quot;,
  &quot;json_class&quot;: &quot;Chef::Role&quot;,
  &quot;run_list&quot;: [
    &quot;role[web]&quot;,
    &quot;recipe[postgresql]&quot;
  ]
}</code></pre> <p>Role can contain attributes inside <code>default_attributes</code> or <code>override_attributes</code> keys. In our example, «web» role can contain general settings for http listen ports, timeout of web server, etc. So let’s look in more detail about the use of attributes.</p> <h2 id="sec:solo-attributes">Attributes</h2> <p>An attribute is a specific detail about a node. Attributes are used by the chef-client to understand:</p> <ul> <li><p>The current state of the node</p></li> <li><p>What the state of the node was at the end of the previous chef-client run</p></li> <li><p>What the state of the node should be at the end of the current chef-client run</p></li> </ul> <p>In our example we install and configure by chef apache 2 web server. In vendor cookbook «apache2» exists default attributes.</p> <pre><code># General settings
default[&#39;apache&#39;][&#39;listen_ports&#39;] = [&quot;80&quot;]
default[&#39;apache&#39;][&#39;contact&#39;] = &quot;ops@example.com&quot;
default[&#39;apache&#39;][&#39;timeout&#39;] = 300
default[&#39;apache&#39;][&#39;keepalive&#39;] = &quot;On&quot;
default[&#39;apache&#39;][&#39;keepaliverequests&#39;] = 100
default[&#39;apache&#39;][&#39;keepalivetimeout&#39;] = 5
...</code></pre> <p>This attributes used, because we don’t override its by environment, role or node. For example, we can add 443 port through our «web» role:</p> <pre><code>{
  &quot;name&quot;: &quot;web&quot;,
  &quot;description&quot;: &quot;The base role for systems that serve web server&quot;,
  &quot;chef_type&quot;: &quot;role&quot;,
  &quot;json_class&quot;: &quot;Chef::Role&quot;,
  &quot;default_attributes&quot;: {
    &quot;apache&quot;: {
      &quot;listen_ports&quot;: [&quot;80&quot;, &quot;443&quot;]
    }
  },
  &quot;run_list&quot;: [
    &quot;recipe[apache2]&quot;
  ]
}</code></pre> <p>Also we can set <code>keepalivetimeout</code> for apache in node attributes:</p> <pre><code>{
  &quot;apache&quot;: {
    &quot;keepalivetimeout&quot;: 30
  },
  &quot;run_list&quot;: [
    &quot;role[web]&quot;
  ]
}</code></pre> <p>If we will set <code>listen_ports</code> in node attribute, when this will override role <code>listen_ports</code> attribute:</p> <pre><code>{
  &quot;apache&quot;: {
    &quot;keepalivetimeout&quot;: 30,
    &quot;listen_ports&quot;: [&quot;80&quot;, &quot;443&quot;, &quot;8080&quot;]
  },
  &quot;run_list&quot;: [
    &quot;role[web]&quot;
  ]
}</code></pre> <p>But role can override attributes, that should be applied to all nodes, even if the node already has a value for an attribute. This is useful for ensuring that certain attributes always have specific values. All this attributes should be written in <code>override_attributes</code> key (instead of <code>default_attributes</code>):</p> <pre><code>{
  &quot;name&quot;: &quot;web&quot;,
  &quot;description&quot;: &quot;The base role for systems that serve web server&quot;,
  &quot;chef_type&quot;: &quot;role&quot;,
  &quot;json_class&quot;: &quot;Chef::Role&quot;,
  &quot;override_attributes&quot;: {
    &quot;apache&quot;: {
      &quot;listen_ports&quot;: [&quot;80&quot;, &quot;443&quot;]
    }
  },
  &quot;run_list&quot;: [
    &quot;recipe[apache2]&quot;
  ]
}</code></pre> <p>More info about attributes you can find on <a href="//docs.opscode.com/chef_overview_attributes.html">wiki page</a>.</p> <h2 id="sec:solo-environment">Defining environments</h2> <p>An environment is a way to map an organization’s real-life workflow to what can be configured and managed when using server. Every organization begins with a single environment called the <code>_default</code> environment, which cannot be modified (or deleted). Additional environments can be created to reflect each organization’s patterns and workflow. For example, creating production, staging, testing, and development environments. Generally, an environment is also associated with one (or more) cookbook versions.</p> <p>We create for our example development environment:</p> <pre><code>{
  &quot;name&quot;: &quot;development&quot;,
  &quot;description&quot;: &quot;development environment&quot;,
  &quot;chef_type&quot;: &quot;environment&quot;,
  &quot;json_class&quot;: &quot;Chef::Environment&quot;,
  &quot;default_attributes&quot;: {
    &quot;apache&quot;: {
      &quot;timeout&quot;: 120
    }
  }
}</code></pre> <p>Let’s consider a json structure:</p> <ul> <li><p><code>name</code> - a unique name of environment</p></li> <li><p><code>description</code> - a description of the environment</p></li> <li><p><code>chef_type</code> - this should always be set to environment</p></li> <li><p><code>json_class</code> - this should always be set to Chef::Environment</p></li> <li><p><code>default_attributes</code> - a set of attributes that should be applied to all nodes, assuming the node does not already have a value for the attribute. This is useful for setting global defaults that can then be overridden for specific nodes. This attribute is optional</p></li> <li><p><code>override_attributes</code> - a set of attributes that should be applied to all nodes, even if the node already has a value for an attribute. This is useful for ensuring that certain attributes always have specific values. This attribute is optional</p></li> </ul> <p>As you can see environment doesn’t have <code>run_list</code>, but it have attributes. Attributes in most cases contain information, which specific for environment: connection information to databases (hostname, port, etc.), cluster settings for database or queue, etc.</p> <p>Now we can activate this development environment in Vagrantfile:</p> <pre><code>Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  ...
    chef.environments_path = Chef::Config[:environment_path]
    chef.environment = ENV[&#39;ENVIRONMENT&#39;] || &#39;development&#39;
  ...
end</code></pre> <p>and check how it works:</p> <pre><code>$ vagrant provision
...
[2013-12-31T21:53:57+00:00] INFO: Chef Run complete in 1.105324838 seconds
[2013-12-31T21:53:57+00:00] INFO: Running report handlers
[2013-12-31T21:53:57+00:00] INFO: Report handlers complete</code></pre> <p>To <code>cook</code> server by knife with environment you should use <code>-E</code> argument:</p> <pre><code>$ knife solo cook vagrant@localhost -i ~/.vagrant.d/insecure_private_key -p 2222 -N web1.example.com -E development
Running Chef on localhost...
Checking Chef version...
...
  * service[apache2] action start (up to date)
Chef Client finished, 1 resources updated</code></pre> <p>You can set environment for node by attribute <code>environment</code>:</p> <pre><code>{
  &quot;environment&quot;: &quot;development&quot;,
  &quot;run_list&quot;: [
    &quot;recipe[apache2]&quot;
  ]
}</code></pre> <p>and use command <code>knife solo cook</code> without <code>-E</code> argument.</p> <p>Once an environment exists on the server, a node can be associated with that environment using the <code>chef_environment</code> method of «node» object in Ruby (I’ll consider this in the next chapters).</p> <p>As you can see in Chef Solo environment can be used only for setting attributes. In Chef Server it have additional feature for locking cookbook versions, which we will consider in «[sec:server-environment] » chapter.</p> <h2 id="sec:solo-data-bag">Defining data bags</h2> <p>A data bag is a global variable that is stored as JSON data. The contents of a data bag can vary, but they often include sensitive information (such as database passwords).</p> <p>Knife is not working with Chef Solo data bags, but we can use <a href="//thbishop.com/knife-solo_data_bag/">knife-solo_data_bag</a> rubygem. Just add this gem in Gemfile:</p> <pre><code>source &quot;https://rubygems.org&quot;

gem &#39;knife-solo&#39;
gem &#39;knife-solo_data_bag&#39;
gem &#39;berkshelf&#39;</code></pre> <p>and run command <code>bundle</code> to install it. After installation you knife should have new commands for working with Chef Solo:</p> <pre><code>$ knife --help | grep solo
  knife solo cook [USER@]HOSTNAME [JSON] (options)
  knife solo init DIRECTORY
  knife solo prepare [USER@]HOSTNAME [JSON] (options)
knife solo bootstrap [USER@]HOSTNAME [JSON] (options)
knife solo clean [USER@]HOSTNAME
knife solo cook [USER@]HOSTNAME [JSON] (options)
knife solo init DIRECTORY
knife solo prepare [USER@]HOSTNAME [JSON] (options)
knife solo data bag create BAG [ITEM] (options)
knife solo data bag edit BAG ITEM (options)
knife solo data bag list (options)
knife solo data bag show BAG [ITEM] (options)
  knife solo clean [USER@]HOSTNAME</code></pre> <p>For beginning, let’s create a plain text data bag:</p> <pre><code>$ EDITOR=vim knife solo data bag create pass mysql
Created data_bag_item[mysql]</code></pre> <p><code>EDITOR</code> environment variable is used to set editor, which will open data bag file. I add in this JSON password for database and save it. Now we can see the result:</p> <pre><code>$ knife solo data bag show pass
mysql:
  id:       mysql
  password: secret</code></pre> <p>If you open data bag file, you will see this JSON:</p> <pre><code>{
  &quot;name&quot;:&quot;data_bag_item_pass_mysql&quot;,
  &quot;chef_type&quot;:&quot;data_bag_item&quot;,
  &quot;json_class&quot;:&quot;Chef::DataBagItem&quot;,
  &quot;data_bag&quot;:&quot;pass&quot;,
  &quot;raw_data&quot;:{
    &quot;id&quot;:&quot;mysql&quot;,
    &quot;password&quot;:&quot;secret&quot;
  }
}</code></pre> <p>Let’s consider a json structure:</p> <ul> <li><p><code>name</code> - a unique name of data bag</p></li> <li><p><code>chef_type</code> - this should always be set to <code>data_bag_item</code></p></li> <li><p><code>json_class</code> - this should always be set to Chef::DataBagItem</p></li> <li><p><code>data_bag</code> - name of data bag</p></li> <li><p><code>raw_data</code> - values of data bag</p></li> </ul> <p>The contents of a data bag can be encrypted using shared secret encryption. This allows a data bag to store confidential information (such as a database password) or to be managed in a source control system (without plain-text data appearing in revision history).</p> <p>Encrypting a data bag requires a secret key. A secret key can be created in any number of ways. For example, OpenSSL can be used to generate a random number, which can then be used as the secret key:</p> <pre><code>$ openssl rand -base64 512 | tr -d &#39;\r\n&#39; &gt; .chef/encrypted_data_bag_secret</code></pre> <p>The <code>tr</code> command eliminates any trailing line feeds. Doing so avoids key corruption when transferring the file between platforms with different line endings.</p> <p>A data bag can be encrypted using a Knife command similar to:</p> <pre><code>$ EDITOR=vim knife solo data bag create passwords mysql --secret-file .chef/encrypted_data_bag_secret
Created data_bag_item[mysql]</code></pre> <p>Editor is opened with such content:</p> <pre><code>{
  &quot;id&quot;: &quot;mysql&quot;
}</code></pre> <p>And you can add you password and save it:</p> <pre><code>{
  &quot;id&quot;: &quot;mysql&quot;,
  &quot;password&quot;: &quot;secret&quot;
}</code></pre> <p>As a result we obtain the encrypted data bag:</p> <pre><code>$ knife solo data bag show passwords mysql
id:       mysql
password:
  cipher:         aes-256-cbc
  encrypted_data: ++RR0s5f3rypFO3+SZj25px9QHTFq7AN854F3XZotnQ=

  iv:             fxvNqHFHHbCNKntW8bBJkg==

  version:        1</code></pre> <p>An encrypted data bag item can be decrypted with a Knife command similar to:</p> <pre><code>$ knife solo data bag show passwords mysql --secret-file .chef/encrypted_data_bag_secret
id:       mysql
password: secret</code></pre> <p>You can set <code>encrypted_data_bag_secret</code> in knife.rb file:</p> <pre><code>cookbook_path    [&quot;cookbooks&quot;, &quot;site-cookbooks&quot;]
node_path        &quot;nodes&quot;
role_path        &quot;roles&quot;
environment_path &quot;environments&quot;
data_bag_path    &quot;data_bags&quot;
encrypted_data_bag_secret &quot;.chef/encrypted_data_bag_secret&quot;

knife[:berkshelf_path] = &quot;cookbooks&quot;</code></pre> <p>and in this case no need to define <code>secret-file</code> for knife data bag commands:</p> <pre><code>$ knife solo data bag show passwords mysql
id:       mysql
password: secret</code></pre> <p>For Vagrant you should set <code>encrypted_data_bag_secret_key_path</code>:</p> <pre><code>...
Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  ...
    chef.encrypted_data_bag_secret_key_path = Chef::Config[:encrypted_data_bag_secret]
  ...
end</code></pre> <p>The Recipe DSL provides access to data bags and data bag items with the following methods: <code>data_bag('bag')</code>, where bag is the name of the data bag and <code>data_bag_item('bag', 'item')</code>, where bag is the name of the data bag and item is the name of the data bag item. Examples:</p> <pre><code>data_bag(&quot;pass&quot;)
# =&gt; [&quot;mysql&quot;]
item = data_bag_item(&quot;pass&quot;, &quot;mysql&quot;)
item[&quot;password&quot;]
# =&gt; &quot;secret&quot;</code></pre> <p>A recipe can access encrypted data bag items as long as the recipe is running on a node that has access to the shared-key that is required to decrypt the data. A secret can be specified by using the Chef::EncryptedDataBagItem.load method. For example:</p> <pre><code>mysql_creds = Chef::EncryptedDataBagItem.load(&quot;passwords&quot;, &quot;mysql&quot;, secret_key)
mysql_creds[&quot;password&quot;]
# =&gt; &quot;secret&quot;</code></pre> <p>where <code>secret_key</code> is the argument that specifies the location of the file that contains the encryption key. An encryption key can be configured so that the chef-client knows where to look using the <code>Chef::Config[:encrypted_data_bag_secret]</code> method, which defaults to <code>/etc/chef/encrypted_data_bag_secret</code>. When the default location is used, the argument that specifies the secret key file location is assumed to be the default and does not need to be explicitly specified in the recipe. For example:</p> <pre><code>mysql_creds = Chef::EncryptedDataBagItem.load(&quot;passwords&quot;, &quot;mysql&quot;)
mysql_creds[&quot;password&quot;]
# =&gt; &quot;secret&quot;</code></pre> <h2 id=summary-1>Summary</h2> <p>Chef Solo is a most simple way to begin working with Chef. Also it is very good choice, if your environment small (several servers) and you don’t need setup or buy separate Chef Server. But if you have huge numbers of servers or you don’t like limited functionality of Chef Solo, in this case you should thinking to setup or buy own Chef Server.</p> <h1 id=chef-server>Chef Server</h1> <p>The Chef Server acts as a hub for configuration data. The server stores cookbooks, the policies that are applied to nodes, and metadata that describes each registered node that is being managed by the chef-client. Nodes use the chef-client to ask the server for configuration details, such as recipes, templates, and file distributions. The chef-client then does as much of the configuration work as possible on the nodes themselves (and not on the server). This scalable approach distributes the configuration effort throughout the organization.</p> <p>The diagram [fig:overview<sub>c</sub>hef<sub>d</sub>raft] shows the relationships between the various elements of Chef, including the nodes, the server, and the workstations. These elements work together to provide the chef-client the information and instruction that it needs so that it can do its job.</p> <p>[fig:overview<sub>c</sub>hef<sub>d</sub>raft]</p> <p>We will learn Chef Server by practical examples in this chapter.</p> <h2 id="sec:server-installation">Installation</h2> <p>Exists several ways to install own Chef Server:</p> <ul> <li><p>Go to <a href="//www.getchef.com/chef/install/">www.getchef.com/chef/install</a>, select the operating system, version, and architecture of the server and install the downloaded package on it. After installation you can configure server by command «sudo chef-server-ctl reconfigure»</p></li> <li><p>Use Chef Solo to install Chef Server</p></li> </ul> <p>Of course, I prefer to use Chef Solo to install and configure Chef Server. Chef Solo will help us quickly deploy Chef Server on a new server, if something happens with it (crash file system of server, etc.). Do not forget to make a backups of Chef Server (because compared with Chef Solo, Chef Server will be the point of failure in your configuration management system).</p> <p>Let’s create our folder, which will contain all our Chef kitchen:</p> <pre><code>$ mkdir my-server-cloud
$ cd my-server-cloud
$ cat Gemfile
source &quot;https://rubygems.org&quot;

gem &#39;chef&#39;
gem &#39;berkshelf&#39;
$ bundle
$ git clone https://github.com/opscode/chef-repo.git .
# or you can use &quot;knife solo init .&quot;, if you will install knife-solo</code></pre> <p>To install and configure Chef Server exists cookbook <a href="https://supermarket.getchef.com/cookbooks/chef-server">chef-server</a>. Let’s add this cookbook in Berkshelf:</p> <pre><code>source &quot;http://api.berkshelf.com&quot;

cookbook &#39;chef-server&#39;</code></pre> <p>After running the command «berks install» this cookbook will be installed with dependencies.</p> <pre><code>$ berks install
Installing chef-server (2.0.1) from site: &#39;http://cookbooks.opscode.com/api/v1/cookbooks&#39;
$ berks install --path cookbooks
Using chef-server (2.0.1)</code></pre> <p>Now we should configure a Chef Solo node for our Chef Server. From chapter «[sec:solo-node] » you should know how to define node.</p> <pre><code>{
  &quot;fqdn&quot;: &quot;10.33.33.33&quot;,
  &quot;chef-server&quot;: {
    &quot;api_fqdn&quot;: &quot;10.33.33.33&quot;,
    &quot;version&quot;: &quot;latest&quot;,
    &quot;configuration&quot;: {
      &quot;notification_email&quot;: &quot;notify@example.com&quot;,
      &quot;chef-server-webui&quot;: {
        &quot;enable&quot;: true
      }
    }
  },
  &quot;run_list&quot;: [
    &quot;recipe[chef-server]&quot;
  ]
}</code></pre> <p>By <code>configuration</code> key you can change settings for Chef Server. All available setting, which can be redefined, you can find <a href="https://github.com/opscode/omnibus-chef-server/blob/master/files/chef-server-cookbooks/chef-server/attributes/default.rb">here</a>. Our Chef Server by default takes your systems <a href="//en.wikipedia.org/wiki/Fully_qualified_domain_name">FQDN</a> as Chef Server url, what is why I set «fqdn» in node IP 10.33.33.33, which will set to my server by Vagrant.</p> <p>First, we should generate Vagrantfile:</p> <pre><code>$ vagrant init precise64
A `Vagrantfile` has been placed in this directory. You are now
ready to `vagrant up` your first virtual environment! Please read
the comments in the Vagrantfile as well as documentation on
`vagrantup.com` for more information on using Vagrant.</code></pre> <p>Next we need modeling a cluster of machines by Vagrant. Right now we need only chef server. Let’s modify Vagrantfile:</p> <pre><code># -*- mode: ruby -*-
# vi: set ft=ruby :

require &#39;chef&#39;
require &#39;json&#39;

Chef::Config.from_file(File.join(File.dirname(__FILE__), &#39;.chef&#39;, &#39;knife.rb&#39;))

chef_server_json = JSON.parse(Pathname(__FILE__).dirname.join(&#39;nodes&#39;, &#39;chef-server.example.com.json&#39;).read)

# Vagrantfile API/syntax version. Don&#39;t touch unless you know what you&#39;re doing!
VAGRANTFILE_API_VERSION = &quot;2&quot;

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|

  config.vm.define :chef_server do |chef_server|
    chef_server.vm.box = &quot;precise64&quot;
    chef_server.vm.network &quot;private_network&quot;, ip: &quot;10.33.33.33&quot;

    chef_server.vm.provision :chef_solo do |chef|
      chef.cookbooks_path = Chef::Config[:cookbook_path]
      chef.roles_path = Chef::Config[:role_path]
      chef.data_bags_path = Chef::Config[:data_bag_path]
      chef.environments_path = Chef::Config[:environment_path]

      chef.run_list = chef_server_json.delete(&#39;run_list&#39;)
      chef.json = chef_server_json
    end
  end

end</code></pre> <p>You should have installed chef gem inside vagrant, as we did in chapter «[sec:solo-vagrant] » and install/update Chef Client inside server by command «knife solo prepare».</p> <pre><code>$ vagrant provision
[chef_server] Running provisioner: chef_solo...
Generating chef JSON and uploading...
Running chef-solo...
stdin: is not a tty
INFO: Forking chef instance to converge...
INFO: *** Chef 11.8.2 ***
INFO: Chef-client pid: 1831
INFO: Setting the run_list to [&quot;recipe[chef-server]&quot;] from JSON
INFO: Run List is [recipe[chef-server]]
INFO: Run List expands to [chef-server]
...</code></pre> <p>We can check Chef Server web interface by <a href="https://10.33.33.33">https://10.33.33.33</a> and info about libraries version by <a href="https://10.33.33.33/version">https://10.33.33.33/version</a> url. It should looks like on figure [fig:chef-server-versions].</p> <p>[fig:chef-server-versions]</p> <p>I most cases web interface give information about your cloud, which you can get from knife tool. What is why generally it disabled by attribute «chef-server-webui.enable = false».</p> <p>Next we should configure our knife to work with this Chef Server.</p> <h2 id="sec:server-knife">Knife</h2> <p>After installation Chef Server with default settings, Chef will generate pem keys, which will be used for knife and Chef clients for authentication with server. We should copy its from our Chef Server to «.chef» directory in project:</p> <pre><code>$ vagrant ssh chef_server
Welcome to Ubuntu 12.04.1 LTS (GNU/Linux 3.2.0-23-generic x86_64)

vagrant@precise64:~$ sudo cp /etc/chef-server/*.pem /vagrant/.chef/</code></pre> <p>On real (production) Chef Server you can use <code>scp</code> command.</p> <p>Next we should create for knife configuration file. As you remember from chapter «[sec:solo-chef-folder] », we already have «.chef» folder with <code>knife.rb</code> config. But for Chef server we should define additional params. We can use for this <code>configure</code> command of knife:</p> <pre><code>$ knife configure -i
Overwrite .../my-server-cloud/.chef/knife.rb? (Y/N) y
Please enter the chef server URL: [https://macbookproleo:443] https://10.33.33.33
Please enter a name for the new user: [leo]
Please enter the existing admin name: [admin]
Please enter the location of the existing admin&#39;s private key: [/etc/chef-server/admin.pem] .chef/admin.pem
Please enter the validation clientname: [chef-validator]
Please enter the location of the validation key: [/etc/chef-server/chef-validator.pem] .chef/chef-validator.pem
Please enter the path to a chef repository (or leave blank):
Creating initial API user...
Please enter a password for the new user:
Created user[leo]
Configuration file written to .../my-server-cloud/.chef/knife.rb</code></pre> <p>Now our file look like this:</p> <pre><code>log_level                :info
log_location             STDOUT
node_name                &#39;leo&#39;
client_key               &#39;.chef/leo.pem&#39;
validation_client_name   &#39;chef-validator&#39;
validation_key           &#39;.chef/chef-validator.pem&#39;
chef_server_url          &#39;https://10.33.33.33&#39;
syntax_check_cache_path  &#39;.chef/syntax_check_cache&#39;</code></pre> <p>Let’s little modify it:</p> <pre><code>current_dir = File.dirname(__FILE__)

log_level                :info
log_location             STDOUT
node_name                &#39;leo&#39;
client_key               &quot;#{current_dir}/leo.pem&quot;
syntax_check_cache_path  &quot;#{current_dir}/syntax_check_cache&quot;
validation_client_name   &quot;chef-validator&quot;
validation_key           &quot;#{current_dir}/chef-validator.pem&quot;
chef_server_url          &quot;https://10.33.33.33&quot;
cookbook_path            [&quot;#{current_dir}/../cookbooks&quot;, &quot;#{current_dir}/../site-cookbooks&quot;]
node_path                 &quot;#{current_dir}/../nodes&quot;
role_path                 &quot;#{current_dir}/../roles&quot;
data_bag_path             &quot;#{current_dir}/../data_bags&quot;
environment_path          &quot;#{current_dir}/../environments&quot;
#encrypted_data_bag_secret &quot;data_bag_key&quot;

knife[:berkshelf_path] = &quot;cookbooks&quot;</code></pre> <p>Let’s consider an options (part of this options already considered in chapter «[sec:solo-chef-folder]  »):</p> <ul> <li><p><code>chef_server_url</code> - the URL for the Chef Server</p></li> <li><p><code>node_name</code> - the name of the node. This is typically also the same name as the computer from which Knife is run</p></li> <li><p><code>client_key</code> - the location of the file which contains the client key. This key used to authenticate with Chef Server</p></li> <li><p><code>validation_key</code> - the location of the file which contains the key used when a chef-client is registered with a server. A validation key is signed using the <code>validation_client_name</code> for authentication. Default value is <code>/etc/chef/validation.pem</code></p></li> <li><p><code>validation_client_name</code> - the name of the server that–along with the <code>validation_key</code> – is used to determine whether a chef-client may register with a server. The <code>validation_client_name</code> located in the server and client configuration files must match</p></li> <li><p><code>syntax_check_cache_path</code> - all files in a cookbook must contain valid Ruby syntax. Use this setting to specify the location in which Knife caches information about files that have been checked for valid Ruby syntax</p></li> <li><p><code>log_level</code> - log level for knife</p></li> <li><p><code>log_location</code> - log location for knife</p></li> </ul> <p>Now we check what knife can communicate with Chef server:</p> <pre><code>$ knife user list
admin
leo
$ knife client list
chef-validator
chef-webui</code></pre> <p>As you can see we successfully get list of users and clients from our Chef Server.</p> <h2 id="sec:server-node">Bootstrap first node</h2> <p>Once the Chef Server workstation is configured, it can be used to install Chef on one (or more) nodes across the organization using a Knife bootstrap operation. The <code>knife bootstrap</code> command is used to SSH into the target machine, and then do what is needed to allow the chef-client to run on the node. It will install the chef-client executable (if necessary), generate keys, and register the node with the Chef Server. The bootstrap operation requires the IP address or FQDN of the target system, the SSH credentials (username, password or identity file) for an account that has root access to the node, and (if the operating system is not Ubuntu, which is the default distribution used by knife bootstrap) the operating system running on the target system.</p> <p>First, let’s add new server in Vagrantfile:</p> <pre><code>...

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|

  ...

  config.vm.define :chef_first_client do |chef_client|
    chef_client.vm.box = &quot;precise64&quot;
    chef_client.vm.network &quot;private_network&quot;, ip: &quot;10.33.33.34&quot;
  end

end</code></pre> <p>And reload vagrant servers:</p> <pre><code>$ vagrant halt chef_server
[chef_server] Attempting graceful shutdown of VM...
$ vagrant up
Bringing machine &#39;chef_server&#39; up with &#39;virtualbox&#39; provider...
Bringing machine &#39;chef_client&#39; up with &#39;virtualbox&#39; provider...
...</code></pre> <p>And now we can bootstrap node:</p> <pre><code>$ knife bootstrap localhost -x vagrant -p 2200 -i ~/.vagrant.d/insecure_private_key -N first.example.com --sudo
Bootstrapping Chef on localhost
localhost --2014-01-05 16:01:33--  https://www.opscode.com/chef/install.sh
...
localhost Chef Client finished, 0 resources updated
$ knife node list
first.example.com</code></pre> <p>And we can check what node created on server:</p> <pre><code>$ knife node list
first.example.com
$ knife client show first.example.com
admin:      false
chef_type:  client
json_class: Chef::ApiClient
name:       first.example.com
public_key: -----BEGIN PUBLIC KEY-----
...
-----END PUBLIC KEY-----

validator:  false</code></pre> <h3 id=node-in-vagrant>Node in Vagrant</h3> <p>You can automate registration of node with your Chef Server in Vagrant. Let’s add new node in Vagrantfile:</p> <pre><code>...

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  ...
  config.vm.define :chef_second_client do |chef_client|
    chef_client.vm.box = &quot;precise64&quot;
    chef_client.vm.network &quot;private_network&quot;, ip: &quot;10.33.33.35&quot;
    chef_client.vm.provision :chef_client do |chef|
      chef.chef_server_url = Chef::Config[:chef_server_url]
      chef.validation_key_path = Chef::Config[:validation_key]
      chef.validation_client_name = Chef::Config[:validation_client_name]
      chef.node_name = &#39;second.example.com&#39;

      chef.delete_node = true
      chef.delete_client = true
    end
  end

end</code></pre> <p>As you can see, options for «chef_client» the same as we set in knife.rb. After command <code>vagrant up</code> you can check what new node registered:</p> <pre><code>$ knife node list
first.example.com
second.example.com</code></pre> <p>When you provision your Vagrant virtual machine with Chef server, it creates a new Chef node entry and Chef client entry on the Chef server, using the hostname of the machine. After you tear down your guest machine, Vagrant can be configured to do it automatically with the following settings:</p> <pre><code>chef.delete_node = true
chef.delete_client = true</code></pre> <p>If you don’t specify it or set it to false, you must explicitly delete these entries from the Chef server before you provision a new one with Chef server. For example, using Chef’s built-in knife tool:</p> <pre><code>$ knife node delete second.example.com
$ knife client delete second.example.com</code></pre> <p>Example of vagrant output when destroy a node:</p> <pre><code>$ vagrant destroy chef_second_client
Are you sure you want to destroy the &#39;chef_second_client&#39; VM? [y/N] y
[chef_second_client] Forcing shutdown of VM...
[chef_second_client] Destroying VM and associated drives...
[chef_second_client] Running cleanup tasks for &#39;chef_client&#39; provisioner...
Deleting client &quot;second.example.com&quot; from Chef server...
Deleting node &quot;second.example.com&quot; from Chef server...
$ knife node list
first.example.com
$ knife client list
chef-validator
chef-webui
first.example.com</code></pre> <p>As you can see node and client removed from Chef server automatically.</p> <h2 id="sec:server-attributes">Attributes</h2> <p>An attribute is a specific detail about a node. Attributes are used by the chef-client to understand:</p> <ul> <li><p>The current state of the node</p></li> <li><p>What the state of the node was at the end of the previous chef-client run</p></li> <li><p>What the state of the node should be at the end of the current chef-client run</p></li> </ul> <p>As you read from previous sections of book, attributes can be defined in node, roles and environments, but it’s also can be defined by cookbooks.</p> <h3 id=attribute-types>Attribute Types</h3> <p>Attribute types can be any of the following:</p> <ul> <li><p><code>default</code> - attribute is automatically reset at the start of every chef-client run and has the lowest attribute precedence</p></li> <li><p><code>force_default</code> - attribute is used to ensure that an attribute defined in a cookbook (by an attribute file or by a recipe) takes precedence over a default attribute set by a role or an environment</p></li> <li><p><code>normal</code> - attribute is a setting that persists on the target system and is never reset during a chef-client run. A normal attribute has a higher attribute precedence than a default attribute</p></li> <li><p><code>override</code> - attribute is automatically reset at the start of every chef-client run and has a higher attribute precedence than default, force_default, and normal attributes. An override attribute is most often specified in a recipe, but can be specified in an attribute file, for a role, and/or for an environment</p></li> <li><p><code>force_override</code> - attribute is used to ensure that an attribute defined in a cookbook (by an attribute file or by a recipe) takes precedence over an override attribute set by a role or an environment</p></li> <li><p><code>automatic</code> - attribute contains data that is identified by Ohai at the beginning of every chef-client run. An automatic attribute cannot be modified and always has the highest attribute precedence</p></li> </ul> <p>At the beginning of a chef-client run, all default, override, and automatic attributes are reset. The chef-client rebuilds them using data collected by Ohai at the beginning of the chef-client run and by attributes that are defined in cookbooks, roles, and environments. Normal attributes are never reset. All attributes are then merged and applied to the node according to attribute precedence. At the conclusion of the chef-client run, all default, override, and automatic attributes disappear, leaving only a collection of normal attributes that will persist until the next chef-client run.</p> <h3 id=automatic-ohai>Automatic (Ohai)</h3> <p>An automatic attribute is a specific detail about a node, such as an IP address, a host name, a list of loaded kernel modules, and so on. Automatic attributes are detected by Ohai and are then used by the chef-client to ensure that these attribute are handled properly during every chef-client run. The most commonly accessed automatic attributes are:</p> <ul> <li><p><code>node['platform']</code> - the platform on which a node is running. This attribute helps determine which providers will be used</p></li> <li><p><code>node['platform_version']</code> - the version of the platform. This attribute helps determine which providers will be used</p></li> <li><p><code>node['ipaddress']</code> - the IP address for a node. If the node has a default route, this is the IPV4 address for the interface. If the node does not have a default route, the value for this attribute should be nil. The IP address for default route is the recommended default value</p></li> <li><p><code>node['macaddress']</code> - the MAC address for a node, determined by the same interface that detects the «node[’ipaddress’]»</p></li> <li><p><code>node['fqdn']</code> - the fully qualified domain name for a node. This is used as the name of a node unless otherwise set</p></li> <li><p><code>node['hostname']</code> - the host name for the nod</p></li> <li><p><code>node['domain']</code> - the domain for the node</p></li> <li><p><code>node['recipes']</code> - a list of recipes associated with a node (and part of that node’s run-list)</p></li> <li><p><code>node['roles']</code> - a list of roles associated with a node (and part of that node’s run-list)</p></li> </ul> <p>The list of automatic attributes that are collected by Ohai at the start of each chef-client run vary from organization to organization, and will often vary between the various server types being configured and the platforms on which those servers are run. All attributes collected by Ohai are unmodifiable by the chef-client.</p> <h3 id=attribute-precedence>Attribute Precedence</h3> <p>Attribute types can be any of the following:</p> <ol> <li><p>A <code>default</code> attribute located in a cookbook attribute file</p></li> <li><p>A <code>default</code> attribute located in a recipe</p></li> <li><p>A <code>default</code> attribute located in an environment</p></li> <li><p>A <code>default</code> attribute located in role</p></li> <li><p>A <code>force_default</code> attribute located in a cookbook attribute file</p></li> <li><p>A <code>force_default</code> attribute located in a recipe</p></li> <li><p>A <code>normal</code> attribute located in a cookbook attribute file</p></li> <li><p>A <code>normal</code> attribute located in a recipe</p></li> <li><p>An <code>override</code> attribute located in a cookbook attribute file</p></li> <li><p>An <code>override</code> attribute located in a recipe</p></li> <li><p>An <code>override</code> attribute located in a role</p></li> <li><p>An <code>override</code> attribute located in an environment</p></li> <li><p>A <code>force_override</code> attribute located in a cookbook attribute file</p></li> <li><p>A <code>force_override</code> attribute located in a recipe</p></li> <li><p>An <code>automatic</code> attribute identified by Ohai at the start of the chef-client run</p></li> </ol> <p>where the last attribute in the list is the one that is applied to the node.</p> <p>Attribute precedence, viewed from the same perspective as the overview diagram [fig:overview<sub>c</sub>hef<sub>a</sub>ttributes<sub>p</sub>recedence], where the numbers in the diagram match the order of attribute precedence:</p> <p>[fig:overview<sub>c</sub>hef<sub>a</sub>ttributes<sub>p</sub>recedence]</p> <p>Attribute precedence [fig:overview<sub>c</sub>hef<sub>a</sub>ttributes<sub>t</sub>able], when viewed as a table:</p> <p>[fig:overview<sub>c</sub>hef<sub>a</sub>ttributes<sub>t</sub>able]</p> <h2 id="sec:server-role">Role</h2> <p>Role work in the same way, as in Chef Solo (chapter «[sec:solo-role] »). For example, we will install on «first.example.com» <a href="https://supermarket.getchef.com/cookbooks/nginx">nginx</a>. First of all, we need add nginx cookbook in Berksfile:</p> <pre><code>source &quot;http://api.berkshelf.com&quot;

cookbook &#39;chef-server&#39;
cookbook &#39;nginx&#39;
cookbook &#39;yum&#39;, &#39;~&gt; 3.0&#39;</code></pre> <p>After command <code>berks install</code> we will create «nginx» role:</p> <pre><code>{
  &quot;name&quot;: &quot;nginx&quot;,
  &quot;description&quot;: &quot;The base role for systems that serve web server&quot;,
  &quot;chef_type&quot;: &quot;role&quot;,
  &quot;json_class&quot;: &quot;Chef::Role&quot;,
  &quot;default_attributes&quot;: {
    &quot;nginx&quot;: {
      &quot;install_method&quot;: &quot;source&quot;,
      &quot;version&quot;: &quot;1.6.0&quot;,
      &quot;default_site_enabled&quot;: true,
      &quot;source&quot;: {
        &quot;url&quot;: &quot;http://nginx.org/download/nginx-1.6.0.tar.gz&quot;
      },
      &quot;worker_rlimit_nofile&quot;: 30000,
      &quot;worker_connections&quot;: 4000
    }
  },
  &quot;run_list&quot;: [
    &quot;recipe[nginx]&quot;
  ]
}</code></pre> <p>And «first.example.com» node:</p> <pre><code>{
  &quot;name&quot;: &quot;first.example.com&quot;,
  &quot;json_class&quot;: &quot;Chef::Node&quot;,
  &quot;chef_type&quot;: &quot;node&quot;,
  &quot;normal&quot;: {
    &quot;fqdn&quot;: &quot;10.33.33.34&quot;
  },
  &quot;default&quot;: {},
  &quot;override&quot;: {},
  &quot;run_list&quot;: [
    &quot;role[nginx]&quot;
  ]
}</code></pre> <p>As you can see, node have different format, than Chef Solo. Keys <code>normal</code>, <code>default</code> and <code>override</code> contain attributes. Difference of this attributes you can read in chapter «[sec:server-attributes] ». Now we should upload cookbooks, role and node in Chef Server. For this we can use knife and berkshelf:</p> <pre><code>// upload all cookbooks from path &#39;cookbooks&#39; and &#39;site-cookbooks&#39; (use --force if cookbook frozen).
// But for vendor cookbooks before you need execute &#39;berks install --path cookbooks&#39;
$ knife cookbook upload -a
// upload selected cookbook
$ knife cookbook upload nginx
// or upload all cookbooks by berks
$ berks upload
// create/update role from file
$ knife role from file roles/nginx.json
// update node from file
$ knife node from file nodes/first.example.com.json</code></pre> <p>Next we should use <code>knife ssh</code> command to do something on nodes. The <code>knife ssh</code> subcommand is used to invoke SSH commands (in parallel) on a subset of nodes within an organization, based on the results of a search query. Example:</p> <pre><code>// execute on &#39;first.example.com&#39; chef-client
$ knife ssh &#39;name:first.example.com&#39; &#39;sudo chef-client&#39; -i ~/.vagrant.d/insecure_private_key -x vagrant
10.33.33.34 Starting Chef Client, version 11.8.2
10.33.33.34 resolving cookbooks for run list: [&quot;nginx::source&quot;]
...
10.33.33.34 Recipe: nginx::source
10.33.33.34   * service[nginx] action nothing (up to date)
10.33.33.34   * service[nginx] action reload
10.33.33.34     - reload service service[nginx]
10.33.33.34
10.33.33.34 Chef Client finished, 4 resources updated</code></pre> <p>Second time you run this command can cause errors like «Failed to connect to». It is because FQDN set by Ohai in chef-client will not visible hostname (in my example nodes have «precise64» hostname). In real cluster you will not have such problems, because you will use real hostnames. But in our case we can use Vagrant «chef_client» stuff. Let’s create node «second.example.com» and upload it on server:</p> <pre><code>{
  &quot;name&quot;: &quot;second.example.com&quot;,
  &quot;json_class&quot;: &quot;Chef::Node&quot;,
  &quot;chef_type&quot;: &quot;node&quot;,
  &quot;normal&quot;: {
    &quot;fqdn&quot;: &quot;10.33.33.35&quot;
  },
  &quot;default&quot;: {},
  &quot;override&quot;: {},
  &quot;run_list&quot;: [
    &quot;role[nginx]&quot;
  ]
}</code></pre> <pre><code>$ knife node from file nodes/second.example.com.json</code></pre> <p>Now you can just run <code>vagrant provision</code> for second node:</p> <pre><code>$ vagrant provision chef_second_client
[chef_second_client] Running provisioner: chef_client...
Creating folder to hold client key...
Uploading chef client validation key...
Generating chef JSON and uploading...
[chef_second_client] Warning: Chef run list is empty. This may not be what you want.
Running chef-client...
stdin: is not a tty
INFO: Forking chef instance to converge...
INFO: *** Chef 11.8.2 ***
INFO: Chef-client pid: 1198
...
INFO: Running report handlers
INFO: Report handlers complete</code></pre> <p>It will run chef-client on server, which will get all needed info how to «cook» node from Chef Server. After this you can check what on url <a href="//10.33.33.35/">http://10.33.33.35/</a> running nginx.</p> <h2 id="sec:server-environment">Environment</h2> <p>Environment in Chef Server is similar to Chef Solo (chapter «[sec:solo-environment] »). Except default attributes, environment in Chef Server can contain <code>cookbook_versions</code> attribute. In this attribute you can lock cookbook versions. Example:</p> <pre><code>{
  &quot;name&quot;: &quot;development&quot;,
  &quot;description&quot;: &quot;development environment&quot;,
  &quot;chef_type&quot;: &quot;environment&quot;,
  &quot;json_class&quot;: &quot;Chef::Environment&quot;,
  &quot;default_attributes&quot;: {},
  &quot;cookbook_versions&quot;: {
    &quot;nginx&quot;: &quot;= 2.2.0&quot;
  }
}</code></pre> <p>As you can see we locked nginx to 2.2.0 version for development environment. This is very useful stuff, because when released new versions of some cookbooks, you need check what you can update it to new version without break a production environment. In this case you can change version of cookbooks inside <code>cookbook_versions</code> in your test (development, staging, etc.) environment, check what all work fine with new cookbook and update production environment only in success case.</p> <p>Set environment to node similar to Chef Solo, but in this case you should use <code>chef_environment</code> attribute. Example:</p> <pre><code>{
  &quot;name&quot;: &quot;second.example.com&quot;,
  &quot;json_class&quot;: &quot;Chef::Node&quot;,
  &quot;chef_type&quot;: &quot;node&quot;,
  &quot;chef_environment&quot;: &quot;development&quot;,
  &quot;normal&quot;: {
    &quot;fqdn&quot;: &quot;10.33.33.35&quot;
  },
  &quot;default&quot;: {},
  &quot;override&quot;: {},
  &quot;run_list&quot;: [
    &quot;role[nginx]&quot;
  ]
}</code></pre> <p>To check what all work fine, first of all you should upload you environment and update node in Chef Server:</p> <pre><code>$ knife environment from file environments/development.json
Updated Environment development

$ knife node from file nodes/second.example.com.json
Updated Node second.example.com!</code></pre> <p>And check what all work fine by command <code>vagrant provision</code> for second node:</p> <pre><code>$ vagrant provision chef_second_client
[chef_second_client] Running provisioner: chef_client...
Creating folder to hold client key...
Uploading chef client validation key...
Generating chef JSON and uploading...
...</code></pre> <h2 id="sec:server-knife-ssh">Knife ssh</h2> <p>The knife ssh subcommand is used to invoke SSH commands (in parallel) on a subset of nodes within an organization, based on the results of a search query. We already use it to run chef-client on «first.example.com» node. Let’s consider an examples.</p> <p>To find the uptime of all of web servers (all node, which have role «web»):</p> <pre><code>$ knife ssh &quot;role:web&quot; &quot;uptime&quot; -i ../keys/production.pem -x ubuntu
***.com    13:18:28 up 55 days, 14 min,  1 user,  load average: 0.00, 0.01, 0.05
***.com    13:18:28 up 75 days, 23:49,  1 user,  load average: 0.00, 0.01, 0.05
***.com    13:18:28 up 55 days, 13 min,  1 user,  load average: 0.08, 0.03, 0.05</code></pre> <p>To run the chef-client on all nodes:</p> <pre><code>$ knife ssh &#39;name:*&#39; &#39;sudo chef-client&#39; -i ../keys/production.pem -x ubuntu
...</code></pre> <p>To run the chef-client on all nodes, which name begin from «second» string:</p> <pre><code>$ knife ssh &#39;name:second*&#39; &#39;sudo chef-client&#39; -i ../keys/production.pem -x ubuntu
...</code></pre> <p>To upgrade all nodes (don’t do this on real production nodes):</p> <pre><code>$ knife ssh &#39;name:*&#39; &#39;sudo aptitude upgrade -y&#39; -i ../keys/production.pem -x ubuntu
...</code></pre> <p>To get memory information from all nodes in staging environment:</p> <pre><code>$ knife ssh &quot;chef_environment:staging&quot; &quot;free -m&quot; -i ../keys/production.pem -x ubuntu
***.com              total       used       free     shared    buffers     cached
***.com Mem:          1692       1182        509          0        181        491
***.com -/+ buffers/cache:        509       1183
***.com Swap:          895          6        889
...</code></pre> <h3 id=chef-client-cookbook>Chef-client cookbook</h3> <p>Sometimes you may want update you servers automatically (instead using <code>knife ssh</code>). For example, you just updated new cookbooks, roles and nodes and all nodes should automatically fetch new cookbooks and apply changes if something updated (and for you not critical update speed). We can use special cookbook <a href="https://supermarket.getchef.com/cookbooks/chef-client">chef-client</a> for this. It allow for use bluepill, daemontools, runit or cron to configure your systems to run Chef Client as a service. First of all we need add this cookbook in Berksfile and run <code>berks install</code>:</p> <pre><code>source &quot;http://api.berkshelf.com&quot;

cookbook &#39;chef-server&#39;
cookbook &#39;nginx&#39;
cookbook &#39;yum&#39;, &#39;~&gt; 3.0&#39;
cookbook &#39;chef-client&#39;</code></pre> <p>Next we will create new node:</p> <pre><code>{
  &quot;name&quot;: &quot;chef-client&quot;,
  &quot;description&quot;: &quot;The base role for chef-client&quot;,
  &quot;chef_type&quot;: &quot;role&quot;,
  &quot;json_class&quot;: &quot;Chef::Role&quot;,
  &quot;default_attributes&quot;: {
    &quot;chef_client&quot;: {
      &quot;interval&quot;: 1800,
      &quot;init_style&quot;: &quot;upstart&quot;,
      &quot;config&quot;: {
        &quot;client_fork&quot;: true
      }
    }
  },
  &quot;run_list&quot;: [
    &quot;recipe[chef-client]&quot;,
    &quot;recipe[chef-client::config]&quot;
  ]
}</code></pre> <p>We set by attributes to check Chef each 1800 sec (30 min) and use «fork» method for execution of chef-client.</p> <p>Next add <code>chef-client</code> in node <code>run_list</code>:</p> <pre><code>{
  &quot;name&quot;: &quot;second.example.com&quot;,
  &quot;json_class&quot;: &quot;Chef::Node&quot;,
  &quot;chef_type&quot;: &quot;node&quot;,
  &quot;chef_environment&quot;: &quot;development&quot;,
  &quot;normal&quot;: {
    &quot;fqdn&quot;: &quot;10.33.33.35&quot;
  },
  &quot;default&quot;: {},
  &quot;override&quot;: {},
  &quot;run_list&quot;: [
    &quot;role[chef-client]&quot;,
    &quot;role[nginx]&quot;
  ]
}</code></pre> <p>After upload coobooks, role and nodes on Chef Server, we can check what chef-client will be added to upstart:</p> <pre><code>$ vagrant provision chef_second_client
[chef_second_client] Running provisioner: chef_client...
Creating folder to hold client key...
Uploading chef client validation key...
...
INFO: service[chef-client] restarted
INFO: Chef Run complete in 9.599237616 seconds
INFO: Running report handlers
INFO: Report handlers complete</code></pre> <p>By command <code>knife status</code> you can check chef-client status on nodes:</p> <pre><code>$ knife status
3 minutes ago, first.example.com, precise64, 10.0.2.14, ubuntu 12.04.
2 minutes ago, second.example.com, precise64, 10.0.2.15, ubuntu 12.04.</code></pre> <p>Of course, you can filter this list, if you have too many nodes (filter by role, environment, etc.):</p> <pre><code>$ knife status &#39;name:second*&#39;
4 minutes ago, second.example.com, precise64, 10.0.2.15, ubuntu 12.04.
$ knife status &#39;role:nginx&#39;
6 minutes ago, first.example.com, precise64, 10.0.2.14, ubuntu 12.04.
5 minutes ago, second.example.com, precise64, 10.0.2.15, ubuntu 12.04.</code></pre> <h2 id="sec:server-data-bags">Data bags</h2> <p>Data bags work similar as in Chef Solo (chapter «[sec:solo-data-bag] »). But in your recipe you can use <code>search</code> command to search data bags on servers. Any search for a data bag (or a data bag item) must specify the name of the data bag and then provide the search query string that will be used during the search. For example, to use Knife to search within a data bag named «admin_data» across all items, except for the «admin_users» item, enter the following:</p> <pre><code>$ knife search admin_data &quot;(NOT id:admin_users)&quot;</code></pre> <p>Or, to include the same search query in a recipe, use a code block similar to:</p> <pre><code>search(:admin_data, &quot;NOT id:admin_users&quot;)</code></pre> <p>It may not be possible to know which data bag items will be needed. It may be necessary to load everything in a data bag (but not know what «everything» is). Using a search query is the ideal way to deal with that ambiguity, yet still ensure that all of the required data is returned. The following examples show how a recipe can use a series of search queries to search within a data bag named «admins». For example, to find every administrator:</p> <pre><code>search(:admins, &quot;*:*&quot;)</code></pre> <p>Or to search for an administrator named «charlie»:</p> <pre><code>search(:admins, &quot;id:charlie&quot;)</code></pre> <p>Or to search for an administrator with a group identifier of «ops»:</p> <pre><code>search(:admins, &quot;gid:ops&quot;)</code></pre> <p>Or to search for an administrator whose name begins with the letter «c»:</p> <pre><code>search(:admins, &quot;id:c*&quot;)</code></pre> <p>Data bag items that are returned by a search query can be used as if they were a hash. For example:</p> <pre><code>charlie = search(:admins, &quot;id:charlie&quot;).first
# =&gt; variable &#39;charlie&#39; is set to the charlie data bag item
charlie[&quot;gid&quot;]
# =&gt; &quot;ops&quot;
charlie[&quot;shell&quot;]
# =&gt; &quot;/bin/zsh&quot;</code></pre> <h2 id=summary-2>Summary</h2> <p>Chef is a systems and cloud infrastructure automation framework that makes it easy to deploy servers and applications to any physical, virtual, or cloud location, no matter the size of the infrastructure.</p> <h1 id=writing-cookbooks>Writing Cookbooks</h1> <p>A cookbook is the fundamental unit of configuration and policy distribution. Each cookbook defines a scenario, such as everything needed to install and configure MySQL, and then it contains all of the components that are required to support that scenario.</p> <p>As you read from previous chapter vendor cookbooks can help you to install and configure any possible software, but in most cases it is not enough. This is because you have your application, which need install, configure special cases only for this application. What is why you must to know how to write own Chef cookbooks.</p> <p>Chef cookbooks is written on <a href="https://www.ruby-lang.org">Ruby</a> language. It is dynamic and open source programming language, which very well fit to use as <a href="//en.wikipedia.org/wiki/Domain-specific_language">DSL</a> for Chef recipes. Before you start reading this chapter, you should know Ruby at least basic stuff (Ruby types, loops, conditions, ERB, etc).</p> <h2 id="sec:cookbook-files">Cookbook file organization</h2> <p>For beginning we will generate cookbook by knife or berks. You can install both by bundler (we already did this in our Chef server kitchens). So, let’s create «my_cool_app» cookbook inside «site-cookbooks» dir:</p> <pre><code>$ cd site-cookbooks
$ knife cookbook create my_cool_app -o .
# or another way by berks
$ berks cookbook my_cool_app</code></pre> <p>After this you should see inside «site-cookbooks» new folder «my_cool_app». This is our cookbook, which have such file structure inside:</p> <pre><code>$ ls -l my_cool_app
total 72
drwxr-xr-x  .
drwxr-xr-x  ..
drwxr-xr-x  .git
-rw-r--r--  .gitignore
-rw-r--r--  Berksfile
-rw-r--r--  Gemfile
-rw-r--r--@ LICENSE
-rw-r--r--  README.md
-rw-r--r--  Thorfile
-rw-r--r--  Vagrantfile
drwxr-xr-x  attributes
-rw-r--r--  chefignore
drwxr-xr-x  definitions
drwxr-xr-x  files
drwxr-xr-x  libraries
-rw-r--r--  metadata.rb
drwxr-xr-x  providers
drwxr-xr-x  recipes
drwxr-xr-x  resources
drwxr-xr-x  templates</code></pre> <p>Let’s consider this structure:</p> <ul> <li><p><code>.git</code> - git repository skeleton (no need to do «git init»)</p></li> <li><p><code>.gitignore</code> - specifies intentionally untracked files to ignore by Git</p></li> <li><p><code>Berksfile</code> - file with cookbook dependencies for berkshelf (used for testing)</p></li> <li><p><code>Gemfile</code> - file with gems for bundler (used for testing)</p></li> <li><p><code>LICENSE</code> - file contain license information about cookbook</p></li> <li><p><code>README.md</code> - file contains information about cookbook. «.md» mean <a href="//daringfireball.net/projects/markdown/syntax">markdown</a> syntax</p></li> <li><p><code>Thorfile</code> - file include tasks for thor gem (toolkit for building command-line interfaces, used for testing)</p></li> <li><p><code>Vagrantfile</code> - file describe the type of machine required for a cookbook for vagrant</p></li> <li><p><code>attributes</code> - this folder contain ruby files with default cookbook attributes, which you can redefine in environment, role or node attributes</p></li> <li><p><code>chefignore</code> - specifies intentionally untracked files to ignore by Chef, Knife</p></li> <li><p><code>definitions</code> - this folder contain ruby files which is used to declare resources so they can be added to the resource collection</p></li> <li><p><code>files</code> - this folder contain files, which just need transfer to node (used by command <code>cookbook_file</code>)</p></li> <li><p><code>libraries</code> - this folder contain ruby files with Ruby code to be included in a cookbook, either as a way to extend the classes used by the chef-client or to implement a new class directly</p></li> <li><p><code>metadata.rb</code> - a file, which contain all information (metadata) about the cookbook: name, dependencies, etc. (it is like gemset for ruby gems, package.json for npm, etc)</p></li> <li><p><code>providers</code> - this folder contain providers for chef resources</p></li> <li><p><code>recipes</code> - this folder contain recipes of this cookbook</p></li> <li><p><code>resources</code> - this folder contain resources for chef (like build-in cron, deploy, etc)</p></li> <li><p><code>templates</code> - this folder contain files written in a markup language that allows the contents of a file to be dynamically generated based on variables or complex logic. Used an Embedded Ruby (ERB) templates.</p></li> </ul> <h2 id="sec:cookbook-metadata">Metadata</h2> <p>Metadata is file, which contain all main information about cookbook. Let’s consider our generated example:</p> <pre><code>name             &#39;my_cool_app&#39;
maintainer       &#39;YOUR_NAME&#39;
maintainer_email &#39;YOUR_EMAIL&#39;
license          &#39;All rights reserved&#39;
description      &#39;Installs/Configures my_cool_app&#39;
long_description IO.read(File.join(File.dirname(__FILE__), &#39;README.md&#39;))
version          &#39;0.1.0&#39;</code></pre> <p>This file written on Ruby and can have such settings:</p> <ul> <li><p><code>name</code> - the name of the cookbook</p></li> <li><p><code>maintainer</code> - the name of the person responsible for maintaining a cookbook, either an individual or an organization</p></li> <li><p><code>maintainer_email</code> - the email address for the person responsible for maintaining a cookbook. Only one email can be listed here</p></li> <li><p><code>license</code> - the type of license under which a cookbook is distributed: «Apache v2.0», «GPL v2», «GPL v3», «MIT», or license «Proprietary - All Rights Reserved» (default)</p></li> <li><p><code>description</code> - a short description of a cookbook and its functionality</p></li> <li><p><code>long_description</code> - a longer description that ideally contains full instructions on the proper use of a cookbook, including definitions, libraries, dependencies, and so on. In example the contents pulled from «README.md» file</p></li> <li><p><code>version</code> - the current version of a cookbook. Version numbers always follow a simple three-number version sequence</p></li> <li><p><code>attribute</code> - the list of attributes that are required to configure a cookbook</p></li> <li><p><code>depends</code> - indicates that a cookbook has a dependency on another cookbook</p></li> <li><p><code>recommends</code> - adds a dependency on another cookbook that is recommended, but not required</p></li> <li><p><code>suggests</code> - adds a dependency on another cookbook that is suggested, but not required</p></li> <li><p><code>conflicts</code> - indicates that a cookbook conflicts with another cookbook or cookbook version</p></li> <li><p><code>grouping</code> - adds a title and description to a group of attributes within a namespace</p></li> <li><p><code>provides</code> - adds a recipe, definition, or resource that is provided by this cookbook, should the auto-populated list be insufficient</p></li> <li><p><code>recipe</code> - a description for a recipe, mostly for cosmetic value within the server user interface</p></li> <li><p><code>replaces</code> - indicates that this cookbook should replace another (and can be used in-place of that cookbook)</p></li> <li><p><code>supports</code> - indicates that a cookbook has a supported platform</p></li> </ul> <p>We need modify it to set our information about this cookbook:</p> <pre><code>name             &#39;my_cool_app&#39;
maintainer       &#39;Alexey Vasiliev&#39;
maintainer_email &#39;leopard_ne@inbox.ru&#39;
license          &#39;MIT&#39;
description      &#39;Installs/Configures my_cool_app&#39;
long_description IO.read(File.join(File.dirname(__FILE__), &#39;README.md&#39;))
version          &#39;0.1.0&#39;</code></pre> <p>As of writing this cookbook, we will be adding information to this file on it.</p> <h2 id="sec:cookbook-resources">Resources and Providers</h2> <p>As you read from previous chapter, Chef inside have resources (in example we used <code>package</code> resource). A resource defines the actions that can be taken, such as when a package should be installed, whether a service should be enabled or restarted, which groups, users, or groups of users should be created, where to put a collection of files, what the name of a new directory should be, and so on. During a chef-client run, each resource is identified and then associated with a provider. The provider then does the work to complete the action defined by the resource. Each resource is processed in the same order as they appear in a recipe. The chef-client ensures that the same actions are taken the same way everywhere and that actions produce the same result every time. A resource is implemented within a recipe using Ruby.</p> <p>Let’s look at the most necessary resources.</p> <h3 id=bash>Bash</h3> <p>The bash resource is used to execute scripts using the Bash interpreter and includes all of the actions and attributes that are available to the execute resource. Example:</p> <pre><code>bash &quot;install_something&quot; do
  user &quot;root&quot;
  cwd &quot;/tmp&quot;
  code «-EOH
  wget http://www.example.com/tarball.tar.gz
  tar -zxf tarball.tar.gz
  cd tarball
  ./configure
  make
  make install
  EOH
end</code></pre> <h3 id=cron>Cron</h3> <p>The cron resource is used to manage cron entries for time-based job scheduling. Attributes for a schedule will default to * if not provided. The cron resource requires access to a crontab program, typically cron. Example:</p> <pre><code>cron &quot;name_of_cron_entry&quot; do
  hour &quot;8&quot;
  weekday &quot;6&quot;
  mailto &quot;admin@opscode.com&quot;
  action :create
end</code></pre> <pre><code>cron &quot;noop&quot; do
  hour &quot;5&quot;
  minute &quot;0&quot;
  command &quot;/bin/true&quot;
end</code></pre> <h3 id=directory>Directory</h3> <p>The directory resource is used to manage a directory, which is a hierarchy of folders that comprises all of the information stored on a computer. The root directory is the top-level, under which the rest of the directory is organized. The directory resource uses the name attribute to specify the path to a location in a directory. Typically, permission to access that location in the directory is required. Example:</p> <pre><code>directory &quot;/tmp/something&quot; do
  owner &quot;root&quot;
  group &quot;root&quot;
  mode 00755
  action :create
end</code></pre> <pre><code>%w{dir1 dir2 dir3}.each do |dir|
  directory &quot;/tmp/mydirs/#{dir}&quot; do
    mode 00775
    owner &quot;root&quot;
    group &quot;root&quot;
    action :create
    recursive true
  end
end</code></pre> <h3 id=git>Git</h3> <p>The git resource is used to manage source control resources that exist in a git repository. git version 1.6.5 (or higher) is required to use all of the functionality in the git resource. Example:</p> <pre><code>git &quot;/opt/mysources/couch&quot; do
  repository &quot;git://git.apache.org/couchdb.git&quot;
  reference &quot;master&quot;
  action :sync
end</code></pre> <pre><code>git &quot;#{Chef::Config[:file_cache_path]}/ruby-build&quot; do
 repository &quot;git://github.com/sstephenson/ruby-build.git&quot;
 reference &quot;master&quot;
 action :sync
end

bash &quot;install_ruby_build&quot; do
 cwd &quot;#{Chef::Config[:file_cache_path]}/ruby-build&quot;
 user &quot;rbenv&quot;
 group &quot;rbenv&quot;
 code «-EOH
   ./install.sh
   EOH
 environment &#39;PREFIX&#39; =&gt; &quot;/usr/local&quot;
end</code></pre> <h3 id=link>Link</h3> <p>The link resource is used to create symbolic or hard links. Example:</p> <pre><code>link &quot;/tmp/passwd&quot; do
  to &quot;/etc/passwd&quot;
end</code></pre> <pre><code>link &quot;/tmp/passwd&quot; do
  to &quot;/etc/passwd&quot;
  link_type :hard
end</code></pre> <h3 id=cookbook_file>Cookbook_file</h3> <p>The cookbook_file resource is used to transfer files from a sub-directory of the files/ directory in a cookbook to a specified path that is located on the host running the chef-client or chef-solo. The file in a cookbook is selected according to file specificity, which allows different source files to be used based on the hostname, host platform (operating system, distro, or as appropriate), or platform version. Files that are located under COOKBOOK_NAME/files/default can be used on any platform. Example:</p> <pre><code>cookbook_file &quot;/tmp/testfile&quot; do
  source &quot;testfile&quot;
  mode 00644
end</code></pre> <pre><code>cookbook_file &quot;/etc/yum.repos.d/custom.repo&quot; do
  source &quot;custom&quot;
  mode 00644
  notifies :run, &quot;execute[create-yum-cache]&quot;, :immediately
  notifies :create, &quot;ruby_block[reload-internal-yum-cache]&quot;, :immediately
end</code></pre> <h3 id=template>Template</h3> <p>The template resource is used to manage file contents with an embedded Ruby (erb) template. This resource includes actions and attributes from the file resource. Template files managed by the template resource follow the same file specificity rules as the remote_file and file resources. Example:</p> <pre><code>template &quot;/tmp/config.conf&quot; do
  source &quot;config.conf.erb&quot;
end</code></pre> <pre><code>template &quot;/tmp/somefile&quot; do
  mode 00644
  source &quot;somefile.erb&quot;
  not_if {File.exists?(&quot;/etc/passwd&quot;)}
end</code></pre> <h3 id=script>Script</h3> <p>The script resource is used to execute scripts using the specified interpreter (Bash, Csh, Perl, Python, or Ruby) and includes all of the actions and attributes that are available to the execute resource. Example:</p> <pre><code>script &quot;install_something&quot; do
  interpreter &quot;bash&quot;
  user &quot;root&quot;
  cwd &quot;/tmp&quot;
  code «-EOH
  wget http://www.example.com/tarball.tar.gz
  tar -zxf tarball.tar.gz
  cd tarball
  ./configure
  make
  make install
  EOH
end</code></pre> <h3 id=user>User</h3> <p>The user resource is used to add users, update existing users, remove users, and to lock/unlock user passwords. Example:</p> <pre><code>user &quot;random&quot; do
  supports :manage_home =&gt; true
  comment &quot;Random User&quot;
  uid 1234
  gid &quot;users&quot;
  home &quot;/home/random&quot;
  shell &quot;/bin/bash&quot;
  password &quot;$1$JJsvHslV$szsCjVEroftprNn4JHtDi.&quot;
end</code></pre> <p>There are a number of encryption options and tools that can be used to create a password shadow hash. In general, using a strong encryption method like SHA-512 and the passwd command in the OpenSSL toolkit is a good approach, however the encryption options and tools that are available may be different from one distribution to another. The following examples show how the command line can be used to create a password shadow hash. When using the <code>passwd</code> command in the OpenSSL tool:</p> <pre><code>$ openssl passwd -1 &quot;theplaintextpassword&quot;</code></pre> <p>When using <code>mkpasswd</code>:</p> <pre><code>$ mkpasswd -m sha-512</code></pre> <p>Another example:</p> <pre><code>user &quot;systemguy&quot; do
  comment &quot;system guy&quot;
  system true
  shell &quot;/bin/false&quot;
end</code></pre> <h3 id=deploy>Deploy</h3> <p>The deploy resource is used to manage and control deployments. This is a popular resource, but is also complex, having the most attributes, multiple providers, the added complexity of callbacks, plus four attributes that support layout modifications from within a recipe.</p> <p>The deploy resource is modeled after <a href="//capistranorb.com/">Capistrano</a>, a utility and framework for executing commands in parallel on multiple remote machines via SSH. The deploy resource is designed to behave in a way that is similar to the <code>deploy</code> and <code>deploy:migration</code> tasks in Capistrano.</p> <h2 id="sec:cookbook-recipes">Recipes</h2> <p>Any cookbook contains recipes. The default recipe inside cookbook have name «default». Let’s add our default recipe, which will install <a href="//git-scm.com/">git</a>:</p> <pre><code>#
# Cookbook Name:: my_cool_app
# Recipe:: default
#
# Copyright (C) 2014 Alexey Vasiliev
#
# MIT
#

package &#39;git&#39;</code></pre> <p>As you can see, at the beginning of recipe we have comments about this recipe. Next we add resource «package» with argument «git». The «package» resource is used to manage packages on the system. For example, on Debian or Ubuntu resource «package» will use «apt-get» command to install git on system.</p> <p>Now you should add «my_cool_app» into run-list to use this cookbook:</p> <pre><code>{
  &quot;name&quot;: &quot;second.example.com&quot;,
  &quot;json_class&quot;: &quot;Chef::Node&quot;,
  &quot;chef_type&quot;: &quot;node&quot;,
  &quot;chef_environment&quot;: &quot;development&quot;,
  &quot;normal&quot;: {
    &quot;fqdn&quot;: &quot;10.33.33.35&quot;
  },
  &quot;default&quot;: {},
  &quot;override&quot;: {},
  &quot;run_list&quot;: [
    &quot;role[chef-client]&quot;,
    &quot;role[nginx]&quot;,
    &quot;recipe[my_cool_app]&quot;
  ]
}</code></pre> <p>If you using Chef Server, don’t forget upload this cookbook and update node on Chef Server by knife.</p> <pre><code>$ knife cookbook upload my_cool_app
Uploading my_cool_app    [0.1.0]
Uploaded 1 cookbook.
$ knife node from file nodes/second.example.com.json
Updated Node second.example.com!
// on real environment you will execute &quot;knife ssh &#39;name:second.example.com&#39; &#39;sudo chef-client&#39; -i ../keys/production.pem -x ubuntu&quot;
$ vagrant provision chef_second_client
INFO: Chef Run complete in 26.935610739 seconds
INFO: Running report handler</code></pre> <p>Let’s install also <a href="//en.wikipedia.org/wiki/Network_Time_Protocol">ntp</a> package in the same recipe. Because we have in recipe Ruby syntax, we can little <a href="//ru.wikipedia.org/wiki/Dont_repeat_yourself">DRY</a> our code:</p> <pre><code>%w(git ntp).each do |pack|
  package pack
end</code></pre> <p>Again upload cookbook and run chef-client:</p> <pre><code>$ knife cookbook upload my_cool_app
Uploading my_cool_app    [0.1.0]
Uploaded 1 cookbook.
// on real environment you will execute &quot;knife ssh &#39;name:second.example.com&#39; &#39;sudo chef-client&#39; -i ../keys/production.pem -x ubuntu&quot;
$ vagrant provision chef_second_client
INFO: Chef Run complete in 26.935610739 seconds
INFO: Running report handler
$ vagrant ssh chef_second_client
...
vagrant@precise64:~$ ps ax | grep ntp
 1115 ?        Ss     0:00 /usr/sbin/ntpd -p /var/run/ntpd.pid -g -u 103:108
13839 pts/2    S+     0:00 grep --color=auto ntp
vagrant@precise64:~$ git --version
git version 1.7.9.5</code></pre> <p>As you can see our simple cookbook is working.</p> <h3 id=assign-dependencies>Assign Dependencies</h3> <p>If a cookbook has a dependency on a recipe that is located in another cookbook, that dependency must be declared in the metadata.rb file for that cookbook using the depends keyword.</p> <p>For example, if the following recipe is included in a cookbook named «my_app»:</p> <pre><code>include_recipe &quot;apache2::mod_ssl&quot;</code></pre> <p>Then the metadata.rb file for that cookbook would have:</p> <pre><code>depends &quot;apache2&quot;</code></pre> <h3 id=create-exceptions>Create Exceptions</h3> <p>A recipe can write events to a log file and can cause exceptions using <code>Chef::Log</code>. The levels include debug, info, warn, error, and fatal. For example, to just capture information:</p> <pre><code>Chef::Log.info(&#39;some useful information&#39;)</code></pre> <p>Or to trigger a fatal exception:</p> <pre><code>Chef::Log.fatal!(&#39;something bad&#39;)</code></pre> <h3 id=include-recipes>Include Recipes</h3> <p>A recipe can include one (or more) recipes located in external cookbooks by using the <code>include_recipe</code> method. When a recipe is included, the resources found in that recipe will be inserted (in the same exact order) at the point where the <code>include_recipe</code> keyword is located. The syntax for including a recipe is like this:</p> <pre><code>include_recipe &quot;recipe&quot;</code></pre> <p>For example:</p> <pre><code>include_recipe &quot;apache2::mod_ssl&quot;</code></pre> <p>If the <code>include_recipe</code> method is used more than once to include a recipe, only the first inclusion is processed and any subsequent inclusions are ignored.</p> <h3 id=reload-attributes>Reload Attributes</h3> <p>Attributes sometimes depend on actions taken from within recipes, so it may be necessary to reload a given attribute from within a recipe. For example:</p> <pre><code>ruby_block &#39;some_code&#39; do
  block do
    node.from_file(run_context.resolve_attribute(&quot;COOKBOOK_NAME&quot;, &quot;ATTR_FILE&quot;))
  end
  action :nothing
end</code></pre> <h3 id=accessor-methods>Accessor Methods</h3> <p>Attribute accessor methods are automatically created and the method invocation can be used interchangeably with the keys. For example:</p> <pre><code>default.apache.dir          = &quot;/etc/apache2&quot;
default.apache.listen_ports = [ &quot;80&quot;,&quot;443&quot; ]</code></pre> <p>This is a matter of style and preference for how attributes are reloaded from recipes, and may be seen when retrieving the value of an attribute.</p> <h2 id="sec:cookbook-attributes">Attributes</h2> <p>An attribute can be defined in a cookbook (or a recipe) and then used to override the default settings on a node. When a cookbook is loaded during a chef-client run, these attributes are compared to the attributes that are already present on the node. When the cookbook attributes take precedence over the default attributes, the chef-client will apply those new settings and values during the chef-client run on the node.</p> <p>An attribute file is located in the <code>attributes/</code> sub-directory for a cookbook. When a cookbook is run against a node, the attributes contained in all attribute files are evaluated in the context of the node object. Node methods (when present) are used to set attribute values on a node. For example, the «apache2» cookbook contains an attribute file called <code>default.rb</code>, which contains the following attributes:</p> <pre><code>default[&quot;apache&quot;][&quot;dir&quot;]          = &quot;/etc/apache2&quot;
default[&quot;apache&quot;][&quot;listen_ports&quot;] = [ &quot;80&quot;,&quot;443&quot; ]</code></pre> <p>The use of the node object (node) is implicit in the previous example; the following example defines the node object itself as part of the attribute:</p> <pre><code>node.default[&quot;apache&quot;][&quot;dir&quot;]          = &quot;/etc/apache2&quot;
node.default[&quot;apache&quot;][&quot;listen_ports&quot;] = [ &quot;80&quot;,&quot;443&quot; ]</code></pre> <p>In our cookbook «my_cool_app» we want create directory for web app, add to this directory html file, generate config for nginx and enable this configuration. Let’s add all this by using Chef attributes and resources.</p> <pre><code>default[&#39;my_cool_app&#39;][&#39;web_dir&#39;]       = &#39;/var/www/my_cool_app&#39;
default[&#39;my_cool_app&#39;][&#39;user&#39;]          = &#39;vagrant&#39;
default[&#39;my_cool_app&#39;][&#39;name&#39;]          = &#39;my_cool_app&#39;</code></pre> <pre><code># install needed package
%w(git ntp).each do |pack|
  package pack
end

# create directory for web app
directory node[&#39;my_cool_app&#39;][&#39;web_dir&#39;] do
  owner node[&#39;my_cool_app&#39;][&#39;user&#39;]
  mode &quot;0755&quot;
  recursive true
end

# upload index.html file to web app directory as index.html
cookbook_file &quot;#{node[&#39;my_cool_app&#39;][&#39;web_dir&#39;]}/index.html&quot; do
  owner node[&#39;my_cool_app&#39;][&#39;user&#39;]
  source &quot;index.html&quot;
  mode 0755
end

# create nginx config from temlate nginx.conf.erb
nginx_config = &quot;#{node[&#39;nginx&#39;][&#39;dir&#39;]}&quot; +
  &quot;/sites-available/#{node[&#39;my_cool_app&#39;][&#39;name&#39;]}.conf&quot;
template nginx_config do
  source &quot;nginx.conf.erb&quot;
  mode &quot;0644&quot;
end

# activate nginx.conf in nginx
nginx_site &quot;#{node[&#39;my_cool_app&#39;][&#39;name&#39;]}.conf&quot;</code></pre> <pre><code>server {
    listen 80 default;
    charset utf-8;
    root &lt;%= node[&#39;my_cool_app&#39;][&#39;web_dir&#39;] %&gt;;
}</code></pre> <pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
  &lt;title&gt;My cool app&lt;/title&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=0, maximum-scale=1.0&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;This is my cool web app&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> <pre><code>name             &#39;my_cool_app&#39;
maintainer       &#39;Alexey Vasiliev&#39;
maintainer_email &#39;leopard_ne@inbox.ru&#39;
license          &#39;MIT&#39;
description      &#39;Installs/Configures my_cool_app&#39;
long_description IO.read(File.join(File.dirname(__FILE__), &#39;README.md&#39;))
version          &#39;0.1.0&#39;

recipe &#39;my_cool_app&#39;,   &#39;Configure my cool app&#39;

depends &#39;nginx&#39;,           &#39;~&gt; 2.2.0&#39;</code></pre> <p>As you can see, we add default attributes for recipe. Better to use for cookbook attribute name as root for all attributes - in this case you will not have problem, if several cookbooks will use similar keys for settings. As you can see all attributes of this cookbook located inside «my_cool_app» attribute. In recipe we add needed commands to create and activate our index.html. Also we add to metadata information about recipe and dependence to nginx cookbook (because we used inside our recipe «nginx_site» resource). After upload cookbook at Chef server and run chef-client at the second node, we can see results at <a href="//10.33.33.35">http://10.33.33.35</a> (Pic [fig:my<sub>c</sub>ool<sub>a</sub>pp<sub>i</sub>ndex]):</p> <pre><code>$ knife cookbook upload my_cool_app
Uploading my_cool_app    [0.1.0]
Uploaded 1 cookbook.
// on real environment you will execute &quot;knife ssh &#39;name:second.example.com&#39; &#39;sudo chef-client&#39; -i ../keys/production.pem -x ubuntu&quot;
$ vagrant provision chef_second_client
...
INFO: directory[/var/www/my_cool_app] created directory /var/www/my_cool_app
INFO: directory[/var/www/my_cool_app] owner changed to 1000
INFO: directory[/var/www/my_cool_app] mode changed to 755
INFO: cookbook_file[/var/www/my_cool_app/index.html] created file /var/www/my_cool_app/index.html
INFO: cookbook_file[/var/www/my_cool_app/index.html] updated file contents /var/www/my_cool_app/index.html
INFO: cookbook_file[/var/www/my_cool_app/index.html] owner changed to 1000
INFO: cookbook_file[/var/www/my_cool_app/index.html] mode changed to 755
INFO: template[/etc/nginx/sites-available/my_cool_app.conf] created file /etc/nginx/sites-available/my_cool_app.conf
INFO: template[/etc/nginx/sites-available/my_cool_app.conf] updated file contents /etc/nginx/sites-available/my_cool_app.conf
INFO: template[/etc/nginx/sites-available/my_cool_app.conf] mode changed to 644
INFO: execute[nxensite my_cool_app.conf] ran successfully
INFO: execute[nxensite my_cool_app.conf] sending reload action to service[nginx] (delayed)
INFO: service[nginx] reloaded
...</code></pre> <p>[fig:my<sub>c</sub>ool<sub>a</sub>pp<sub>i</sub>ndex]</p> <h2 id="sec:cookbook-templates">Templates</h2> <p>As you can see in previous chapter we used resource <code>template</code> for generate nginx config in default recipe. A cookbook template is a file written in a markup language that allows the contents of a file to be dynamically generated based on variables or complex logic. Templates can contain Ruby expressions and statements. Templates are a great way to manage configuration files across an organization. A template requires a template resource being added to a recipe and then a corresponding Embedded Ruby (ERB) template being added to a cookbook.</p> <p>To use a template, two things must happen:</p> <ul> <li><p>A template resource must be added to a recipe</p></li> <li><p>An Embedded Ruby (ERB) template must be added to a cookbook</p></li> </ul> <p>For example, the following template file and template resource settings can be used to manage a configuration file named <code>/etc/sudoers</code>. Within a cookbook that uses sudo, the following resource could be added to <code>recipes/default.rb</code>:</p> <pre><code>template &quot;/etc/sudoers&quot; do
  source &quot;sudoers.erb&quot;
  mode 0440
  owner &quot;root&quot;
  group &quot;root&quot;
  variables({
     :sudoers_groups =&gt; node[:authorization][:sudo][:groups],
     :sudoers_users =&gt; node[:authorization][:sudo][:users]
  })
end</code></pre> <p>And then create a template called <code>sudoers.erb</code> and save it to <code>templates/default/sudoers.erb</code>:</p> <pre><code>#
# /etc/sudoers
#
# Generated by Chef for &lt;%= node[:fqdn] %&gt;
#

Defaults        !lecture,tty_tickets,!fqdn

# User privilege specification
root          ALL=(ALL) ALL

&lt;% @sudoers_users.each do |user| -%&gt;
&lt;%= user %&gt;   ALL=(ALL) &lt;%= &quot;NOPASSWD:&quot; if @passwordless %&gt;ALL
&lt;% end -%&gt;

# Members of the sysadmin group may gain root privileges
%sysadmin     ALL=(ALL) &lt;%= &quot;NOPASSWD:&quot; if @passwordless %&gt;ALL

&lt;% @sudoers_groups.each do |group| -%&gt;
# Members of the group &#39;&lt;%= group %&gt;&#39; may gain root privileges
%&lt;%= group %&gt; ALL=(ALL) &lt;%= &quot;NOPASSWD:&quot; if @passwordless %&gt;ALL
&lt;% end -%&gt;</code></pre> <p>And then set the default attributes in <code>attributes/default.rb</code>:</p> <pre><code>default[&quot;authorization&quot;][&quot;sudo&quot;][&quot;groups&quot;] = [ &quot;sysadmin&quot;,&quot;wheel&quot;,&quot;admin&quot; ]
default[&quot;authorization&quot;][&quot;sudo&quot;][&quot;users&quot;]  = [ &quot;jerry&quot;,&quot;greg&quot;]</code></pre> <p>When a template is rendered, Ruby expressions and statements are evaluated by the chef-client. The variables listed in the resource’s variables parameter and the node object are evaluated. The chef-client then passes these variables to the template, where they will be accessible as instance variables within the template; the node object can be accessed just as if it were part of a recipe, using the same syntax.</p> <p>For example, a simple template resource like this:</p> <pre><code>node[:fqdn] = &quot;latte&quot;
template &quot;/tmp/foo&quot; do
  source &quot;foo.erb&quot;
  variables({
    :x_men =&gt; &quot;are keen&quot;
  })
end</code></pre> <p>And a simple Embedded Ruby (ERB) template like this:</p> <pre><code>The node &lt;%= node[:fqdn] %&gt; thinks the x-men &lt;%= @x_men %&gt;</code></pre> <p>Would render something like:</p> <pre><code>The node latte thinks the x-men are keen</code></pre> <p>Even though this is a very simple example, the full capabilities of Ruby can be used to tackle even the most complex and demanding template requirements.</p> <h3 id=file-specificity>File Specificity</h3> <p>A cookbook will frequently be designed to work across many platforms and will often be required to distribute a specific file to a specific platform. A cookbook can be designed to support distributing files across platforms, but ensuring that the right file ends up on each system.</p> <p>The pattern for file specificity is as follows:</p> <ol> <li><p><code>host-node[:fqdn]</code></p></li> <li><p><code>node[:platform]-node[:platform_version]</code></p></li> <li><p><code>node[:platform]-version_components</code>: The version string is split on decimals and searched from greatest specificity to least; for example, if the location from the last rule was centos-5.7.1, then centos-5.7 and centos-5 would also be searched.</p></li> <li><p><code>node[:platform]</code></p></li> <li><p><code>default</code></p></li> </ol> <p>The naming of folders within cookbook directories must literally match the host notation used for template specificity matching. For example, if a host is named «foo.example.com», then the folder must be named «host-foo.example.com».</p> <p>A cookbook may have a <code>/templates</code> directory structure like this:</p> <pre><code>templates/
  windows-6.2
  windows-6.1
  windows-6.0
  windows
  default</code></pre> <p>and a resource that looks something like the following:</p> <pre><code>template &quot;C:\path\to\file\text_file.txt&quot; do
  source &quot;text_file.txt&quot;
  mode 0755
  owner &quot;root&quot;
  group &quot;root&quot;
end</code></pre> <p>This resource would be matched in the same order as the /templates directory structure. For a node named «host-node-desktop» that is running Windows 7, the second item would be the matching item and the location:</p> <pre><code>/templates
  windows-6.2/text_file.txt
  windows-6.1/text_file.txt
  windows-6.0/text_file.txt
  windows/text_file.txt
  default/text_file.txt</code></pre> <h3 id=partial-templates>Partial Templates</h3> <p>A template can be built in a way that allows it to contain references to one (or more) smaller template files. (These smaller template files are also referred to as partials.) A partial can be referenced from a template file in one of the following ways:</p> <ul> <li><p>By using the Ruby render method in the template file</p></li> <li><p>By using the template resource and the variables parameter</p></li> </ul> <p>Use the render method in a template to reference a partial template file with the following syntax:</p> <pre><code>&lt;%= render &quot;partial_name.txt.erb&quot;, :option =&gt; {} %&gt;</code></pre> <p>where <code>partial_name.txt.erb</code> is the name of the partial template file and <code>:option</code> is one (or more) of the following options:</p> <ul> <li><p><code>:cookbook</code> - by default, a partial template file is assumed to be located in the cookbook that contains the top-level template. Use this option to specify the path to a different cookbook</p></li> <li><p><code>:local</code> - indicates that the name of the partial template file should be interpreted as a path to a file in the local file system or looked up in a cookbook using the normal rules for template files. Set to true to interpret as a path to a file in the local file system and to false to use the normal rules for template files</p></li> <li><p><code>:source</code> - by default, a partial template file is identified by its file name. Use this option to specify a different name or a local path to use (instead of the name of the partial template file)</p></li> <li><p><code>:variables</code> - a hash of <code>variable_name =&gt; value</code> that will be made available to the partial template file. When this option is used, any variables that are defined in the top-level template that are required by the partial template file must have them defined explicitly using this option</p></li> </ul> <p>For example:</p> <pre><code>&lt;%= render &quot;simple.txt.erb&quot;, :variables =&gt; {:user =&gt; @user }, :local =&gt; true %&gt;</code></pre> <h2 id="sec:cookbook-lwrp">LWRPs</h2> <p>A LWRP (Lightweight Resources and Providers) is a part of a cookbook that is used to extend the chef-client in a way that allows custom actions to be defined, and then used in recipes in much the same way as any platform resource. A LWRP has two principal components:</p> <ul> <li><p>A lightweight resource that defines a set of actions and attributes</p></li> <li><p>A lightweight provider that tells the chef-client how to handle each action, what to do if certain conditions are met, and so on</p></li> </ul> <p>In addition, most lightweight providers are built using platform resources and some lightweight providers are built using custom Ruby code.</p> <p>Once created, a LWRP becomes a Ruby class within the organization. During each chef-client run, the chef-client will read the lightweight resources from recipes and process them alongside all of the other resources. When it is time to configure the node, the chef-client will use the corresponding lightweight provider to determine the steps required to bring the system into the desired state.</p> <p>Where the lightweight resource represents a piece of the system, its current state, and the action that is needed to move it to the desired state, a lightweight provider defines the steps that are required to bring that piece of the system from its current state to the desired state. A LWRP behaves similar to platform resources and providers:</p> <ul> <li><p>A lightweight resource is a key part of a recipe</p></li> <li><p>A lightweight resource defines the actions that can be taken</p></li> <li><p>During a chef-client run, each lightweight resource is identified, and then associated with a lightweight provider</p></li> <li><p>A lightweight provider does the work to complete the action requested by the lightweight resource</p></li> </ul> <p>Lightweight resources and providers are loaded from files that are saved in the following cookbook sub-directories:</p> <table> <thead> <tr class=header> <th style="text-align: left;">Directory</th> <th style="text-align: left;">Description</th> </tr> </thead> <tbody> <tr class=odd> <td style="text-align: left;">providers/</td> <td style="text-align: left;">The sub-directory in which lightweight providers are located.</td> </tr> <tr class=even> <td style="text-align: left;">resources/</td> <td style="text-align: left;">The sub-directory in which lightweight resources are located.</td> </tr> </tbody> </table> <p>The naming patterns of lightweight resources and providers are determined by the name of the cookbook and by the name of the files in the «resources/» and «providers/» sub-directories. For example, if a cookbook named «example» was downloaded to the chef-repo, it would be located at «/cookbooks/example/». If that cookbook contained two resources and two providers, the following files would be part of the «resources/» directory:</p> <table> <thead> <tr class=header> <th style="text-align: left;">Files</th> <th style="text-align: left;">Resource Name</th> <th style="text-align: left;">Generated Class</th> </tr> </thead> <tbody> <tr class=odd> <td style="text-align: left;">default.rb</td> <td style="text-align: left;">example</td> <td style="text-align: left;">Chef::Resource::Example</td> </tr> <tr class=even> <td style="text-align: left;">custom.rb</td> <td style="text-align: left;">example_custom</td> <td style="text-align: left;">Chef::Resource::ExampleCustom</td> </tr> </tbody> </table> <p>And the following files would be part of the «providers/» directory:</p> <table> <thead> <tr class=header> <th style="text-align: left;">Files</th> <th style="text-align: left;">Provider Name</th> <th style="text-align: left;">Generated Class</th> </tr> </thead> <tbody> <tr class=odd> <td style="text-align: left;">default.rb</td> <td style="text-align: left;">example</td> <td style="text-align: left;">Chef::Provider::Example</td> </tr> <tr class=even> <td style="text-align: left;">custom.rb</td> <td style="text-align: left;">custom</td> <td style="text-align: left;">Chef::Provider::ExampleCustom</td> </tr> </tbody> </table> <p>Let’s add in our «my_cool_app» LWRP, which will add in <code>/etc/ssh/ssh_known_hosts</code> host.</p> <h3 id=resources>Resources</h3> <p>First of all we should create directory «resources» and add to it <code>know_host.rb</code> file with content:</p> <pre><code>actions :create, :delete
default_action :create

attribute :host, :kind_of =&gt; String, :name_attribute =&gt; true, :required =&gt; true
attribute :key, :kind_of =&gt; String
attribute :port, :kind_of =&gt; Fixnum, :default =&gt; 22
attribute :known_hosts_file, :kind_of =&gt; String, :default =&gt; &#39;/etc/ssh/ssh_known_hosts&#39;

# Needed for Chef versions &lt; 0.10.10
def initialize(*args)
  super
  @action = :create
end</code></pre> <p>Let’s take it line by line. The first line specifies the allowed actions. Actions are what your resource can do, e.g. start, stop, create, delete, etc. In this case, you can <code>:create</code> or <code>:delete</code> known host. The next line defines the <code>default_action</code> for our resource, in this case <code>:create</code>. If you don’t specify an action when you use the resource in a recipe, it will default to creating a known host, which is what you probably want. A general philosophy of Chef is to define intelligent or «sane» defaults.</p> <p>Lines 4-7 define attributes, or properties of the known host resource we are creating. Line 4 defines an <code>:host</code> attribute. Its <code>:name_attribute</code> is true, which means that this attribute will be set to the string between <code>my_cool_app_know_host</code> and <code>do</code>. Example:</p> <pre><code>my_cool_app_know_host &quot;Add github host&quot; do
  host &#39;github.com&#39;
end

my_cool_app_know_host &#39;github.com&#39; do
  # The :host attribute will be set to &#39;github.com&#39;
end</code></pre> <p>In the second example above, the <code>:host</code> attribute wll be set to «github.com».</p> <p>Also, on line 4, we are defining the <code>kind_of</code> validation parameter to tell the resource which kind of data we should expect (in this case, a string), whether this attribute is required (yes). Line 5 defines a <code>:key</code> attribute, which is an optional string with no default. Line 6 defines a <code>:port</code> attribute, a Ruby Fixnum (i.e. an integer) with a default of 22, which is the default when you create a known host. Line 7 defines a <code>:known_hosts_file</code> attribute, a string with a default of <code>/etc/ssh/ssh_known_hosts</code>, which is the default file with known hosts for ssh client.</p> <p>For example, the <code>cron_d</code> lightweight resource (found in the cron cookbook) can be used to manage files located in <code>/etc/cron.d</code>:</p> <pre><code>actions :create, :delete
default_action :create

attribute :name, :kind_of =&gt; String, :name_attribute =&gt; true
attribute :cookbook, :kind_of =&gt; String, :default =&gt; &quot;cron&quot;
attribute :minute, :kind_of =&gt; [Integer, String], :default =&gt; &quot;*&quot;
attribute :hour, :kind_of =&gt; [Integer, String], :default =&gt; &quot;*&quot;
attribute :day, :kind_of =&gt; [Integer, String], :default =&gt; &quot;*&quot;
attribute :month, :kind_of =&gt; [Integer, String], :default =&gt; &quot;*&quot;
attribute :weekday, :kind_of =&gt; [Integer, String], :default =&gt; &quot;*&quot;
attribute :command, :kind_of =&gt; String, :required =&gt; true
attribute :user, :kind_of =&gt; String, :default =&gt; &quot;root&quot;
attribute :mailto, :kind_of =&gt; [String, NilClass]
attribute :path, :kind_of =&gt; [String, NilClass]
attribute :home, :kind_of =&gt; [String, NilClass]
attribute :shell, :kind_of =&gt; [String, NilClass]</code></pre> <p>where</p> <ul> <li><p>the <code>actions</code> allow a recipe to manage entries in a crontab file (create entry, delete entry)</p></li> <li><p><code>:create</code> is the default action</p></li> <li><p><code>:minute</code>, <code>:hour</code>, <code>:day</code>, <code>:month</code>, and <code>:weekday</code> are the collection of attributes used to schedule a cron job, assigned a default value of «*»</p></li> <li><p><code>:command</code> is the command that will be run (and also required)</p></li> <li><p><code>:user</code> is the user by which the command is run</p></li> <li><p><code>:mailto</code>, <code>:path</code>, <code>:home</code>, and <code>:shell</code> are optional environment variables that do not have default value, which each being defined as an array that supports the String and NilClass Ruby classes</p></li> </ul> <h3 id=providers>Providers</h3> <p>Now we need to create file <code>know_host.rb</code> in «providers» directory:</p> <pre><code># Support whyrun
def whyrun_supported?
  true
end

use_inline_resources

action :create do
  key, comment = insure_for_file(new_resource)
  # Use a Ruby block to edit the file
  ruby_block &quot;add #{new_resource.host} to #{new_resource.known_hosts_file}&quot; do
    block do
      file = ::Chef::Util::FileEdit.new(new_resource.known_hosts_file)
      file.insert_line_if_no_match(/#{Regexp.escape(comment)}|#{Regexp.escape(key)}/, key)
      file.write_file
    end
  end
  new_resource.updated_by_last_action(true)
end

action :delete do
  key, comment = insure_for_file(new_resource)
  # Use a Ruby block to edit the file
  ruby_block &quot;del #{new_resource.host} from #{new_resource.known_hosts_file}&quot; do
    block do
      file = ::Chef::Util::FileEdit.new(new_resource.known_hosts_file)
      file.search_file_delete_line(/#{Regexp.escape(comment)}|#{Regexp.escape(key)}/)
      file.write_file
    end
  end
  new_resource.updated_by_last_action(true)
end

def insure_for_file(new_resource)
  key = (new_resource.key || `ssh-keyscan -H -p #{new_resource.port} #{new_resource.host} 2&gt;&amp;1`)
  comment = key.split(&quot;\n&quot;).first || &quot;&quot;

  Chef::Application.fatal! &quot;Could not resolve #{new_resource.host}&quot; if key =~ /getaddrinfo/

  # Ensure that the file exists and has minimal content (required by Chef::Util::FileEdit)
  file new_resource.known_hosts_file do
    action        :create
    backup        false
    content       &#39;# This file must contain at least one line. This is that line.&#39;
    only_if do
      !::File.exists?(new_resource.known_hosts_file) || ::File.new(new_resource.known_hosts_file).readlines.length == 0
    end
  end
  [key, comment]
end</code></pre> <h3 id=dsl-methods>DSL Methods</h3> <h4 id=action>action</h4> <p>The action method is used to define the steps that will be taken for each of the possible actions defined by the lightweight resource. Each action must be defined in separate action blocks within the same file. The syntax for the action method is as follows:</p> <pre><code>action :action_name do
  if @current_resource.exists
    Chef::Log.info &quot;#{ @new_resource } already exists - nothing to do.&quot;
  else
    resource &quot;resource_name&quot; do
      Chef::Log.info &quot;#{ @new_resource } created.&quot;
    end
  end
  new_resource.updated_by_last_action(true)
end</code></pre> <p>where:</p> <ul> <li><p><code>:action_name</code> corresponds to an action defined by a lightweight resource</p></li> <li><p>if <code>@current_resource.exists</code> is a condition test that is using an instance variable to see if the object already exists on the node; this is an example of a test for idempotence</p></li> <li><p>If the object already exists, a <code>@new_resource</code> already exists - nothing to do. log entry is created</p></li> <li><p>If the object does not already exists, the resource block is run. This block is a recipe that tells the chef-client what to do. A <code>@new_resource</code> created. log entry is created</p></li> </ul> <h4 id=current_resource>current_resource</h4> <p>The <code>current_resource</code> method is used to represent a resource as it exists on the node at the beginning of the chef-client run. In other words: what the resource is currently. The chef-client compares the resource as it exists on the node to the resource that is created during the chef-client run to determine what steps need to be taken to bring the resource into the desired state. This method is often used as an instance variable (<code>@current_resource</code>).</p> <p>For example:</p> <pre><code>action :add do
  unless @current_resource.exists
    cmd = &quot;#{appcmd} add app /site.name:\&quot;#{@new_resource.app_name}\&quot;&quot;
    cmd « &quot; /path:\&quot;#{@new_resource.path}\&quot;&quot;
    cmd « &quot; /applicationPool:\&quot;#{@new_resource.application_pool}\&quot;&quot; if @new_resource.application_pool
    cmd « &quot; /physicalPath:\&quot;#{@new_resource.physical_path}\&quot;&quot; if @new_resource.physical_path
    Chef::Log.debug(cmd)
    shell_out!(cmd)
    Chef::Log.info(&quot;App created&quot;)
  else
    Chef::Log.debug(&quot;#{@new_resource} app already exists - nothing to do&quot;)
  end
end</code></pre> <p>where the <code>unless</code> conditional statement checks to make sure the resource doesn’t already exist on a node, and then runs a series of commands when it doesn’t. If the resource already exists, the log entry would be «Foo app already exists - nothing to do.»</p> <h4 id=load_current_resource>load_current_resource</h4> <p>The <code>load_current_resource</code> method is used to find a resource on a node based on a collection of attributes. These attributes are defined in a lightweight resource and are loaded by the chef-client when processing a recipe during a chef-client run. This method will ask the chef-client to look on the node to see if a resource exists with specific matching attributes.</p> <p>For example:</p> <pre><code>def load_current_resource
  @current_resource = Chef::Resource::TransmissionTorrentFile.new(@new_resource.name)
  Chef::Log.debug(&quot;#{@new_resource} torrent hash = #{torrent_hash}&quot;)
  path = &quot;foo:#{@new_resource.att1}@#{@new_resource.att2}:#{@new_resource.att3}/path&quot;
  @transmission = Opscode::Transmission::Client.new(path)
  @torrent = nil
  begin
    @torrent = @transmission.get_torrent(torrent_hash)
    info = &quot;Found existing #{@new_resource} in swarm &quot;+
    &quot;with name of &#39;#{@torrent.name}&#39; and status of &#39;#{@torrent.status_message}&#39;&quot;
    Chef::Log.info(info)
    @current_resource.torrent(@new_resource.torrent)
  rescue
    Chef::Log.debug(&quot;Cannot find #{@new_resource} in the swarm&quot;)
  end
  @current_resource
end</code></pre> <p>In the previous example, if a resource exists with matching attributes, the chef-client does nothing and if a resource does not exist with matching attributes, the chef-client will enforce the state declared in <code>new_resource</code>.</p> <h4 id=new_resource>new_resource</h4> <p>The <code>new_resource</code> method is used to represent a resource as loaded by the chef-client during the chef-client run. In other words: what the resource should be. The chef-client compares the resource as it exists on the node to the resource that is created during the chef-client run to determine what steps need to be taken to bring the resource into the desired state.</p> <p>For example:</p> <pre><code>action :delete do
  if exists?
    if ::File.writable?(new_resource.path)
      Chef::Log.info(&quot;Deleting #{new_resource} at #{new_resource.path}&quot;)
      ::File.delete(new_resource.path)
      new_resource.updated_by_last_action(true)
    else
      raise &quot;Cannot delete #{new_resource} at #{new_resource.path}!&quot;
    end
  end
end</code></pre> <p>where the chef-client checks to see if the file exists, then if the file is writable, and then attempts to delete the resource. <code>path</code> is an attribute of the new resource that is defined by the lightweight resource.</p> <h4 id=updated_by_last_action>updated_by_last_action</h4> <p>The <code>updated_by_last_action</code> method is used to notify a lightweight resource that a node was updated successfully. For example, the <code>cron_d</code> lightweight resource in the cron cookbook:</p> <pre><code>action :create do
  t = template &quot;/etc/cron.d/#{new_resource.name}&quot; do
    cookbook new_resource.cookbook
    source &quot;cron.d.erb&quot;
    mode &quot;0644&quot;
    variables({
        :name =&gt; new_resource.name,
        :minute =&gt; new_resource.minute,
        :hour =&gt; new_resource.hour,
        :day =&gt; new_resource.day,
        :month =&gt; new_resource.month,
        :weekday =&gt; new_resource.weekday,
        :command =&gt; new_resource.command,
        :user =&gt; new_resource.user,
        :mailto =&gt; new_resource.mailto,
        :path =&gt; new_resource.path,
        :home =&gt; new_resource.home,
        :shell =&gt; new_resource.shell
      })
    action :create
  end
  t.run_action(:create)
  new_resource.updated_by_last_action(t.updated_by_last_action?)
end</code></pre> <p>where <code>t.updated_by_last_action?</code> uses a variable to check whether a new crontab entry was created. Also you should remember that <code>t.updated_by_last_action?</code> will work only with <code>run_action</code>, without it this method will return always false.</p> <h4 id=use_inline_resources>use_inline_resources</h4> <p>A lightweight resource should be set to inline compile mode by adding the <code>use_inline_resources</code> method at the top of the provider. This ensures that notifications work properly across the resource collection. The <code>use_inline_resources</code> method was added to the chef-client starting in version 11.0 to address the behavior described below. The <code>use_inline_resources</code> method should be considered a requirement for any lightweight resource authored against the 11.0+ versions of the chef-client. This behavior will become the default behavior in an upcoming version of the chef-client.</p> <p>The reason why the <code>use_inline_resources method</code> exists at all is due to how the chef-client processes resources. Currently, the default behavior of the chef-client processes a single collection of resources, converged on the node in order.</p> <p>A lightweight resource is often implemented using the core chef-client resources — <code>file</code>, <code>template</code>, <code>package</code>, and so on—as building blocks. A lightweight resource is then added to a recipe using the short name of the lightweight resource in the recipe (and not by using any of the building block resource components).</p> <p>This situation can create problems with notifications because the chef-client includes embedded resources in the «single collection of resources» after the parent resource has been fully evaluated.</p> <p>For example:</p> <pre><code>custom_resource &quot;something&quot; do
  action :run
  notifies :restart, &quot;service[whatever]&quot;, :immediately
end

service &quot;whatever&quot; do
  action :nothing
end</code></pre> <p>If the <code>custom_resource</code> is built using the file resource, what happens during the chef-client run is:</p> <pre><code>custom_resource (not updated)
  file (updated)
service (skipped, due to ``:nothing``)</code></pre> <p>The <code>custom_resource</code> is converged completely, its state set to not updated before the <code>file</code> resource is evaluated. The <code>notifies :restart</code> is ignored and the service is not restarted.</p> <p>If the author of the custom resource knows in advance what notification is required, then the <code>file</code> resource can be configured for the notification in the provider. For example:</p> <pre><code>action :run do
  file &quot;/tmp/foo&quot; do
    owner &quot;root&quot;
    group &quot;root&quot;
    mode &quot;0644&quot;
    notifies :restart, &quot;service[whatever]&quot;, :immediately
  end
end</code></pre> <p>And then in the recipe:</p> <pre><code>service &quot;whatever&quot; do
  action :nothing
end</code></pre> <p>This approach works, but only when the author of the lightweight resource knows what should be notified in advance of the chef-client run. Consequently, this is less-than-ideal for most situations.</p> <p>Using the <code>use_inline_resources</code> method will ensure that the chef-client processes a lightweight resource as if it were its own resource collection—a «mini chef-client run», effectively—that is converged before the chef-client finishes evaluating the parent lightweight resource. This ensures that any notifications that may exist in the embedded resources are processed as if they were notifications on the parent lightweight resource. For example:</p> <pre><code>custom_resource &quot;something&quot; do
  action :run
  notifies :restart, &quot;service[whatever]&quot;, :immediately
end

service &quot;whatever&quot; do
  action :nothing
end</code></pre> <p>If the <code>custom_resource</code> is built using the <code>file</code> resource, what happens during the chef-client run is:</p> <pre><code>custom_resource (starts converging)
  file (updated)
custom_resource (updated, because ``file`` updated)
service (updates, because ``:immediately`` is set in the custom resource)</code></pre> <p>The <code>use_inline_resources</code> method should be considered a default method for any provider that defines a custom resource. It’s the correct behavior. And it will soon become the default behavior in a future version of the chef-client.</p> <p>Because inline compile mode makes it impossible for embedded resources to notify resources in the parent resource collection, inline compile mode may cause issues with some provider implementations. In these cases, use a definition to work around inline compile mode.</p> <h4 id=whyrun_supported>whyrun_supported?</h4> <p>why-run mode is a way to see what the chef-client would have configured, had an actual chef-client run occurred. This approach is similar to the concept of «no-operation» (or «no-op»): decide what should be done, but then don’t actually do anything until it’s done right. This approach to configuration management can help identify where complexity exists in the system, where inter-dependencies may be located, and to verify that everything will be configured in the desired manner.</p> <p>When why-run mode is enabled, a chef-client run will occur that does everything up to the point at which configuration would normally occur. This includes getting the configuration data, authenticating to the server, rebuilding the node object, expanding the run list, getting the necessary cookbook files, resetting node attributes, identifying the resources, and building the resource collection and does not include mapping each resource to a provider or configuring any part of the system.</p> <p>When the chef-client is run in why-run mode, certain assumptions are made:</p> <ul> <li><p>If the service resource cannot find the appropriate command to verify the status of a service, why-run mode will assume that the command would have been installed by a previous resource and that the service would not be running</p></li> <li><p>For <code>not_if</code> and <code>only_if</code> attribute, why-run mode will assume these are commands or blocks that are safe to run. These conditions are not designed to be used to change the state of the system, but rather to help facilitate idempotency for the resource itself. That said, it may be possible that these attributes are being used in a way that modifies the system state</p></li> <li><p>The closer the current state of the system is to the desired state, the more useful why-run mode will be. For example, if a full run-list is run against a fresh system, that run-list may not be completely correct on the first try, but also that run-list will produce more output than smaller run-list</p></li> </ul> <p>The <code>whyrun_supported?</code> method is used to set a lightweight provider to support why-run mode. The syntax for the <code>whyrun_supported?</code> method is as follows:</p> <pre><code>def whyrun_supported?
  true
end</code></pre> <p>where <code>whyrun_supported?</code> is set to true for any lightweight provider that supports using why-run mode. When why-run mode is supported by the a lightweight provider, the <code>converge_by</code> method is used to define the strings that are logged by the chef-client when it is run in why-run mode.</p> <h4 id=log-entries-and-rescue>Log entries and rescue</h4> <p>Use the <code>Chef::Log</code> class in a lightweight provider to define log entries that are created during a chef-client run. The syntax for a log message is as follows:</p> <pre><code>Chef::Log.log_type(&quot;message&quot;)</code></pre> <p>where</p> <ul> <li><p><code>log_type</code> can be .debug, .info, .warn, .error, or .fatal</p></li> <li><p>«message» is the message that is logged</p></li> </ul> <p>For example, from the «repository.rb» provider in the yum cookbook:</p> <pre><code>action :add do
  unless ::File.exists?(&quot;/etc/yum.repos.d/#{new_resource.repo_name}.repo&quot;)
    Chef::Log.info &quot;Adding #{new_resource.repo_name} repository to /etc/yum.repos.d/#{new_resource.repo_name}.repo&quot;
    repo_config
  end
end</code></pre> <p>where the <code>Chef::Log</code> class appends .info as the log type. If the name of the repo was «foo», then the log message would be «Adding foo repository to /etc/yum.repos.d/foo.repo».</p> <p>Another example shows two log entries, one that is triggered when a service is being restarted, and then another that is triggered after the service has been restarted:</p> <pre><code>action :restart do
  if @current_resource.running
    Chef::Log.debug &quot;Restarting #{new_resource.service_name}&quot;
    shell_out!(restart_command)
    new_resource.updated_by_last_action(true)
    Chef::Log.debug &quot;Restarted #{new_resource.service_name}&quot;
  end
end</code></pre> <p>Use the <code>rescue</code> clause to make sure that a log message is always provided. For example:</p> <pre><code>def load_current_resource
  ...
  begin
    ...
  rescue
    Chef::Log.debug(&quot;Cannot find #{@new_resource} in the swarm&quot;)
  end
  ...
end</code></pre> <h3 id=using-lwrp>Using LWRP</h3> <p>We finished with our LWRP. Let’s test it. Just add to «default.rb» you new LWRP, which will add to known hosts «github.com»:</p> <pre><code># known hosts for github.com
my_cool_app_know_host &#39;github.com&#39;</code></pre> <p>Upload cookbook on server and run chef-client on node:</p> <pre><code>$ knife cookbook upload my_cool_app
  Uploading my_cool_app    [0.1.0]
  Uploaded 1 cookbook.

$ vagrant provision chef_second_client
...
INFO: Found chef-client in /usr/bin/chef-client
INFO: runit_service[nginx] configured
INFO: ruby_block[add github.com to /etc/ssh/ssh_known_hosts] called
INFO: Chef Run complete in 11.920336698 seconds
INFO: Running report handlers
INFO: Report handlers complete

$ vagrant ssh chef_second_client

$ cat /etc/ssh/ssh_known_hosts
# This file must contain at least one line. This is that line.
# github.com SSH-2.0-OpenSSH_5.9p1 Debian-5ubuntu1+github5
|1|fvGKZG+jIkEntM5yBvzJ230TX1o=|9qP2wRdFIS+cAouirLYDb1Ibl7A= ssh-rsa...</code></pre> <p>Let’s check how it will delete this hosts:</p> <pre><code>my_cool_app_know_host &#39;github.com&#39; do
  action :delete
end</code></pre> <p>Again upload on server and run chef-client:</p> <pre><code>$ knife cookbook upload my_cool_app
  Uploading my_cool_app    [0.1.0]
  Uploaded 1 cookbook.

$ vagrant provision chef_second_client
...
INFO: Found chef-client in /usr/bin/chef-client
INFO: runit_service[nginx] configured
INFO: ruby_block[del github.com from /etc/ssh/ssh_known_hosts] called
INFO: Chef Run complete in 17.109379291 seconds
INFO: Running report handlers
INFO: Report handlers complete

$ vagrant ssh chef_second_client

$ cat /etc/ssh/ssh_known_hosts
# This file must contain at least one line. This is that line.</code></pre> <p>As you can see, all works as expected.</p> <h2 id="sec:cookbook-hwrp">HWRPs</h2> <p>When Chef first came out, there was no Lightweight Resources and Providers (LWRP) syntax and any hardcore extension to Chef had to be written in Ruby. However, Chef team saw a need to be filled and created LWRP, making it easier to create your own Resources. The problem comes when LWRP cannot fulfill all of your needs. This means you need to fall back to writing pure ruby code. For lack of a better term, I’ll call this method a HWRP, or Heavyweight Resources and Providers.</p> <p>While writing a LWRP is meant to be simple and elegant, writing a HWRP is meant to be flexible. It gives you the full power of ruby in exchange for elegance.</p> <h3 id=hwrps-and-lwrps>HWRPs and LWRPS</h3> <p>With LWRP you are taught to create a Resource and a Provider together. This is the simplest way. However, just because you need to convert a resource definition or a provider into a HWRP you do not need to convert both.</p> <p>The LWRP syntax «compiles» into real ruby code, so Chef will not know the difference in how they were defined. A valid cookbook directory structure:</p> <pre><code>libraries/
    provider_default.rb
providers/
resources/
    default.rb
recipes/
    default.rb
metadata.rb</code></pre> <p>Anything you put in «resources/» or «providers/» Chef will attempt to parse at runtime. We don’t want Chef trying to read our HWRP as the Chef DSL, we want it to interpret it as code. Luckily, anything stored in the «libraries/» folder Chef will try to import at runtime. A good example of this can be seen in the <a href="https://github.com/hw-cookbooks/runit">runit</a> cookbook.</p> <h3 id=example>Example</h3> <p>Let’s go through an example. We are going to create a HWRP that is very simple, it already written as a LWRP. Our HWRP will called <code>my_cool_app_known_host</code>, to not conflict with already existed in cookbook LWRP <code>my_cool_app_know_host</code>.</p> <h4 id=resource>Resource</h4> <p>First, we need to inherit from the appropriate Chef classes in our HWRP. Note the class hierarchy as well as the inheritance:</p> <pre><code>require &#39;chef/resource&#39;

class Chef
  class Resource
    class MyCoolAppKnownHost &lt; Chef::Resource

    # Some Magic Happens

    end
  end
end</code></pre> <p>Next, we should to override the initialize method to make sure we have some defaults. We aren’t defining all of our resource attributes here, just the ones that need defaults.</p> <pre><code>require &#39;chef/resource&#39;

class Chef
  class Resource
    class MyCoolAppKnownHost &lt; Chef::Resource

      def initialize(name, run_context=nil)
        super
        # Bind ourselves to the name with an underscore
        @resource_name = :my_cool_app_known_host
        # We need to tie to our provider
        @provider = Chef::Provider::MyCoolAppKnownHost
        # Default Action Goes here
        @action = :create
        @allowed_actions = [:create, :delete]

        # Now we need to set up any resource defaults
        @port = 22
        @known_hosts_file = &#39;/etc/ssh/ssh_known_hosts&#39;
        @host = name  # This is equivalent to setting :name_attribute =&gt; true
      end

    end
  end
end</code></pre> <p>Now lets set up some attribute methods in our HWRP. Make sure to read the code comments for an explanation of what is going on.</p> <pre><code>require &#39;chef/resource&#39;

class Chef
  class Resource
    class MyCoolAppKnownHost &lt; Chef::Resource

      def initialize(name, run_context=nil)
        super
        # Bind ourselves to the name with an underscore
        @resource_name = :my_cool_app_known_host
        # We need to tie to our provider
        @provider = Chef::Provider::MyCoolAppKnownHost
        # Default Action Goes here
        @action = :create
        @allowed_actions = [:create, :delete]

        # Now we need to set up any resource defaults
        @port = 22
        @known_hosts_file = &#39;/etc/ssh/ssh_known_hosts&#39;
        @host = name  # This is equivalent to setting :name_attribute =&gt; true
      end

      # Define the attributes we set defaults for
      def key(arg=nil)
        set_or_return(:key, arg, :kind_of =&gt; String)
      end

      def host(arg=nil)
        set_or_return(:host, arg, :kind_of =&gt; String)
      end

      def port(arg=nil)
        set_or_return(:port, arg, :kind_of =&gt; Integer)
      end

      def known_hosts_file(arg=nil)
        set_or_return(:known_hosts_file, arg, :kind_of =&gt; String)
      end

    end
  end
end</code></pre> <h4 id=providers-1>Providers</h4> <p>Very similar to resources, here is the basic class structure for a provider.</p> <pre><code>require &#39;chef/provider&#39;

class Chef
  class Provider
    class MyCoolAppKnownHost &lt; Chef::Provider

    # Magic Happens

    end
  end
end</code></pre> <p>While we don’t need to write an initialize method (we can), we do need to override <code>load_current_resource</code>.</p> <pre><code>require &#39;chef/provider&#39;

class Chef
  class Provider
    class MyCoolAppKnownHost &lt; Chef::Provider

      # We MUST override this method in our custom provider
      def load_current_resource
        # Here we keep the existing version of the resource
        # if none exists we create a new one from the resource we defined earlier
        @current_resource ||= Chef::Resource::MyCoolAppKnownHost.new(new_resource.name)

        # New resource represents the chef DSL block that is being run (from a recipe for example)
        @current_resource.key(new_resource.key)
        @current_resource.port(new_resource.port)
        @current_resource.known_hosts_file(new_resource.known_hosts_file)
        # Although you can reference @new_resource throughout the provider it is best to
        # only make modifications to the current version
        @current_resource.host(new_resource.host)
        @current_resource
      end

    end
  end
end</code></pre> <p>Now it is time to define what we do in our actions, with our HWRP we need to define methods like <code>action_create</code> to define a <code>:create</code> action. Chef will do some introspection to find these methods and hook them up.</p> <pre><code>require &#39;chef/provider&#39;

class Chef
  class Provider
    class MyCoolAppKnownHost &lt; Chef::Provider

      # We MUST override this method in our custom provider
      def load_current_resource
        # Here we keep the existing version of the resource
        # if none exists we create a new one from the resource we defined earlier
        @current_resource ||= Chef::Resource::MyCoolAppKnownHost.new(new_resource.name)

        # New resource represents the chef DSL block that is being run (from a recipe for example)
        @current_resource.key(new_resource.key)
        @current_resource.port(new_resource.port)
        @current_resource.known_hosts_file(new_resource.known_hosts_file)
        # Although you can reference @new_resource throughout the provider it is best to
        # only make modifications to the current version
        @current_resource.host(new_resource.host)
        @current_resource
      end

      def action_create
        Chef::Log.debug(&quot;#{@new_resource}: Create #{new_resource.host}&quot;)
      end

      def action_delete
        Chef::Log.debug(&quot;#{@new_resource}: Delete #{new_resource.host}&quot;)
      end

    end
  end
end</code></pre> <p>Now we can test it.</p> <pre><code>...
my_cool_app_known_host &#39;bitbucket.org&#39;</code></pre> <p>To run chef-client in debug mode you should use <code>-l</code> attribute with settings <code>debug</code>. In vagrant you need set <code>log_level</code> for node in Vagrantfile:</p> <pre><code>chef_client.vm.provision :chef_client do |chef|

  chef.log_level = :debug

  ...
end</code></pre> <p>And see our HWRP execution in log:</p> <pre><code>$ knife cookbook upload my_cool_app
Uploading my_cool_app    [0.1.0]
Uploaded 1 cookbook.

$ vagrant provision chef_second_client
[chef_second_client] Running provisioner: chef_client...
Creating folder to hold client key...
Uploading chef client validation key...
...
DEBUG: my_cool_app_known_host[bitbucket.org]: Create bitbucket.org
DEBUG: Saving the current state of node second.example.com
INFO: Chef Run complete in 15.491575653 seconds
...</code></pre> <p>Now let’s add code for actions <code>:create</code> and <code>:delete</code> (this code similar to LWRP code):</p> <pre><code>require &#39;chef/provider&#39;

class Chef
  class Provider
    class MyCoolAppKnownHost &lt; Chef::Provider

      ...

      def action_create
        Chef::Log.debug(&quot;#{@new_resource}: Create #{new_resource.host}&quot;)

        key, comment = insure_for_file(new_resource)
        # Use a Ruby block to edit the file
        ruby_block &quot;add #{new_resource.host} to #{new_resource.known_hosts_file}&quot; do
          block do
            file = ::Chef::Util::FileEdit.new(new_resource.known_hosts_file)
            file.insert_line_if_no_match(/#{Regexp.escape(comment)}|#{Regexp.escape(key)}/, key)
            file.write_file
          end
        end
        new_resource.updated_by_last_action(true)
      end

      def action_delete
        Chef::Log.debug(&quot;#{@new_resource}: Delete #{new_resource.host}&quot;)

        key, comment = insure_for_file(new_resource)
        # Use a Ruby block to edit the file
        ruby_block &quot;del #{new_resource.host} from #{new_resource.known_hosts_file}&quot; do
          block do
            file = ::Chef::Util::FileEdit.new(new_resource.known_hosts_file)
            file.search_file_delete_line(/#{Regexp.escape(comment)}|#{Regexp.escape(key)}/)
            file.write_file
          end
        end
        new_resource.updated_by_last_action(true)
      end

      private

      def insure_for_file(new_resource)
        key = (new_resource.key || `ssh-keyscan -H -p #{new_resource.port} #{new_resource.host} 2&gt;&amp;1`)
        comment = key.split(&quot;\n&quot;).first || &quot;&quot;

        Chef::Application.fatal! &quot;Could not resolve #{new_resource.host}&quot; if key =~ /getaddrinfo/

        # Ensure that the file exists and has minimal content (required by Chef::Util::FileEdit)
        file new_resource.known_hosts_file do
          action        :create
          backup        false
          content       &#39;# This file must contain at least one line. This is that line.&#39;
          only_if do
            !::File.exists?(new_resource.known_hosts_file) || ::File.new(new_resource.known_hosts_file).readlines.length == 0
          end
        end
        [key, comment]
      end

    end
  end
end</code></pre> <p>And check how it works:</p> <pre><code>$ knife cookbook upload my_cool_app
Uploading my_cool_app    [0.1.0]
Uploaded 1 cookbook.

$ vagrant provision chef_second_client
[chef_second_client] Running provisioner: chef_client...
Creating folder to hold client key...
Uploading chef client validation key...
...
WARN: Cloning resource attributes for file[/etc/ssh/ssh_known_hosts] from prior resource (CHEF-3694)
WARN: Previous file[/etc/ssh/ssh_known_hosts]: /var/chef/cache/cookbooks/my_cool_app/providers/know_host.rb:39:in `insure_for_file&#39;
WARN: Current  file[/etc/ssh/ssh_known_hosts]: /var/chef/cache/cookbooks/my_cool_app/libraries/provider_known_host.rb:62:in `insure_for_file&#39;
INFO: ruby_block[add bitbucket.org to /etc/ssh/ssh_known_hosts] called
...

$ vagrant ssh chef_second_client

vagrant@precise64:~$ cat /etc/ssh/ssh_known_hosts
# This file must contain at least one line. This is that line.
# github.com SSH-2.0-OpenSSH_6.2p2 Ubuntu-6ubuntu0.1+github2
|1|Daaa5BVIzI52zRmJ2ifMfOkkLJE=|Y611mqhJbVkdJ1onVkaqfV+3iks= ...
# bitbucket.org SSH-2.0-OpenSSH_5.3
|1|jycCFcglLajRKYIlyAJaD+zmOjw=|51hFV+x1XIZNdiMGG6K0Xz+Nkds= ...</code></pre> <p>As a result, we wrote HWRP, which performs the same job as LWRP. HWRP is not so simple and elegant as LWRP, but have huge flexibility, because have more control by Ruby language.</p> <h2 id="sec:cookbook-definitions">Definitions</h2> <p>A definition is used to declare resources so they can be added to the resource collection. A definition is not a resource or a lightweight resource. A definition does not have an associated provider. A definition groups two (or more) resource declarations. There is no limit to the number of resources that can be part of a definition. All definitions within a cookbook must be located in the «definitions/» folder. A definition is never declared into a cookbook. A definition is best-used when:</p> <ul> <li><p>Data needs to be passed from one (or more) recipes into a single definition</p></li> <li><p>A repeating usage pattern exists for one (or more) resources</p></li> <li><p>An action does not need to be sent directly to a resource (when it does, it should be sent to a provider)</p></li> </ul> <p>In our <code>my_cool_app</code> cookbook we are using <code>nginx_site</code> definition from nginx cookbook.</p> <p>Right now definitions continue working in Chef, but better to use LWRP (or HWRP) instead definition (in chapter «[sec:testing-foodcritic] » you will see warning about this).</p> <h3 id=example-1>Example</h3> <p>Let’s create definition in our <code>my_cool_app</code> cookbook. We will move our nginx conf creation into definition. Our code:</p> <pre><code># create nginx config from temlate nginx.conf.erb
nginx_config = &quot;#{node[&#39;nginx&#39;][&#39;dir&#39;]}/sites-available/#{node[&#39;my_cool_app&#39;][&#39;name&#39;]}.conf&quot;
template nginx_config do
  source &quot;nginx.conf.erb&quot;
  mode &quot;0644&quot;
end

# activate conf in nginx
nginx_site &quot;#{node[&#39;my_cool_app&#39;][&#39;name&#39;]}.conf&quot;</code></pre> <p>we moved to definition <code>enable_web_site</code>:</p> <pre><code>define :enable_web_site, :enable =&gt; true, :template =&gt; &quot;site.conf.erb&quot; do
  if params[:enable]
    # create nginx config from temlate nginx.conf.erb
    nginx_config = &quot;#{node[&#39;nginx&#39;][&#39;dir&#39;]}/sites-available/#{params[:name]}.conf&quot;
    template nginx_config do
      source params[:template]
      mode &quot;0644&quot;
    end
    # activate conf in nginx
    nginx_site &quot;#{params[:name]}.conf&quot;
  else
    # deactivateconf in nginx
    nginx_site &quot;#{params[:name]}.conf&quot; do
      enable    false
    end
  end
end</code></pre> <p>And now we can replace code in [lst:cookbook-definitions-default1] by call of <code>enable_web_site</code>:</p> <pre><code># enable website
enable_web_site node[&#39;my_cool_app&#39;][&#39;name&#39;] do
  template &quot;nginx.conf.erb&quot;
end</code></pre> <p>Now it remains to check how it works:</p> <pre><code>$ knife cookbook upload my_cool_app
Uploading my_cool_app    [0.1.0]
Uploaded 1 cookbook.

$ vagrant provision chef_second_client
...
INFO: template[/etc/nginx/sites-available/my_cool_app.conf] created file /etc/nginx/sites-available/my_cool_app.conf
INFO: template[/etc/nginx/sites-available/my_cool_app.conf] updated file contents /etc/nginx/sites-available/my_cool_app.conf
INFO: template[/etc/nginx/sites-available/my_cool_app.conf] mode changed to 644
INFO: execute[nxensite my_cool_app.conf] ran successfully
...</code></pre> <p>As you can see our definition works as expected.</p> <h2 id="sec:cookbook-ohai">Ohai</h2> <p>Ohai detects data about your operating system. It can be used standalone, but its primary purpose is to provide node data to Chef.</p> <p>When invoked, it collects detailed, extensible information about the machine it’s running on, including Chef configuration, hostname, FQDN, networking, memory, CPU, platform, and kernel data.</p> <p>When Chef configures the node object during each Chef run, these attributes are used by the chef-client to ensure that certain properties remain unchanged. These properties are also referred to as automatic attributes (which, as you remember, impossible to override by attributes from cookbooks, environments, roles and nodes). For example:</p> <pre><code>node[&#39;platform&#39;] # The platform on which a node is running. This attribute helps determine which providers will be used.
node[&#39;platform_version&#39;]  # The version of the platform. This attribute helps determine which providers will be used.
node[&#39;hostname&#39;]  # The host name for the node.</code></pre> <h3 id=example-2>Example</h3> <p>Let’s create new recipe, which will use Ohai attributes and create our own Ohai attributes.</p> <h4 id=recipe-node>Recipe node</h4> <p>First of all, we will create new recipe «node», which will install <a href="//nodejs.org/">Node.js</a> on nodes in our <code>my_cool_app</code> cookbook.</p> <p>New default attributes:</p> <pre><code>default[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;version&#39;] = &#39;0.10.26&#39;
default[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;checksum&#39;] = &#39;2340ec2dce1794f1ca1c685b56840dd515a271b2&#39;
default[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;dir&#39;] = &#39;/usr/local&#39;
default[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;src_url&#39;] = &quot;http://nodejs.org/dist&quot;</code></pre> <p>And recipe:</p> <pre><code>include_recipe &quot;build-essential&quot;

case node[&#39;platform_family&#39;]
  when &#39;rhel&#39;,&#39;fedora&#39;
    package &quot;openssl-devel&quot;
  when &#39;debian&#39;
    package &quot;libssl-dev&quot;
end

nodejs_tar = &quot;node-v#{node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;version&#39;]}.tar.gz&quot;
nodejs_tar_path = nodejs_tar
if node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;version&#39;].split(&#39;.&#39;)[1].to_i &gt;= 5
  nodejs_tar_path = &quot;v#{node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;version&#39;]}/#{nodejs_tar_path}&quot;
end
# Let the user override the source url in the attributes
nodejs_src_url = &quot;#{node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;src_url&#39;]}/#{nodejs_tar_path}&quot;

remote_file &quot;/usr/local/src/#{nodejs_tar}&quot; do
  source nodejs_src_url
  checksum node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;checksum&#39;]
  mode 0644
  action :create_if_missing
end

# --no-same-owner required overcome &quot;Cannot change ownership&quot; bug
# on NFS-mounted filesystem
execute &quot;tar --no-same-owner -zxf #{nodejs_tar}&quot; do
  cwd &quot;/usr/local/src&quot;
  creates &quot;/usr/local/src/node-v#{node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;version&#39;]}&quot;
end

bash &quot;compile node.js&quot; do
  cwd &quot;/usr/local/src/node-v#{node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;version&#39;]}&quot;
  code «-EOH
    PATH=&quot;/usr/local/bin:$PATH&quot;
    ./configure --prefix=#{node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;dir&#39;]} &amp;&amp; \
    make
  EOH
  creates &quot;/usr/local/src/node-v#{node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;version&#39;]}/node&quot;
end

execute &quot;nodejs make install&quot; do
  environment({&quot;PATH&quot; =&gt; &quot;/usr/local/bin:/usr/bin:/bin:$PATH&quot;})
  command &quot;make install&quot;
  cwd &quot;/usr/local/src/node-v#{node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;version&#39;]}&quot;
  not_if do
    File.exists?(&quot;#{node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;dir&#39;]}/bin/node&quot;) &amp;&amp;
    `#{node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;dir&#39;]}/bin/node --version`.chomp == &quot;v#{node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;version&#39;]}&quot;
  end
end</code></pre> <p>As you can see, we use <code>node['platform_family']</code> Ohai variable, which help for us understand type of OS on node and install needed package.</p> <p>Also we used cookbook <code>build-essential</code>, because we will install node.js from source. In this case we should add it as dependency in our metadata.rb file:</p> <pre><code>depends &#39;nginx&#39;,           &#39;~&gt; 2.2.0&#39;
depends &#39;build-essential&#39;</code></pre> <p>To use this recipe we should add it in <code>run_list</code>:</p> <pre><code>{
  &quot;run_list&quot;: [
    &quot;recipe[my_cool_app]&quot;,
    &quot;recipe[my_cool_app::node]&quot;
  ]
}</code></pre> <p>But I want run this recipe with default recipe, so I will leave <code>run_list</code> as is and add node recipe in default recipe:</p> <pre><code>...
include_recipe &#39;my_cool_app::node&#39;</code></pre> <p>Now it remains to check how it works:</p> <pre><code>$ knife cookbook upload my_cool_app
Uploading my_cool_app    [0.1.0]
Uploaded 1 cookbook.

$ vagrant provision chef_second_client
INFO: remote_file[/usr/local/src/node-v0.10.26.tar.gz] created file /usr/local/src/node-v0.10.26.tar.gz
INFO: remote_file[/usr/local/src/node-v0.10.26.tar.gz] updated file contents /usr/local/src/node-v0.10.26.tar.gz
INFO: remote_file[/usr/local/src/node-v0.10.26.tar.gz] mode changed to 644
INFO: execute[tar --no-same-owner -zxf node-v0.10.26.tar.gz] ran successfully
INFO: bash[compile node.js] ran successfully
INFO: execute[nodejs make install] ran successfully

$ vagrant ssh chef_second_client

vagrant@precise64:~$ node -v
v0.10.26</code></pre> <p>As you can see node recipe installed Node.js on our node.</p> <h4 id=ohai-plugin>Ohai plugin</h4> <p>In our node recipe we used maybe not best way to check node version, which already installed on node (if version mismatch - we should install needed). Let’s create Ohai plugin, which will give for use node.js version from server. First of all create in <code>my_cool_app</code> new recipe <code>ohai_plugin.rb</code> with content:</p> <pre><code>template &quot;#{node[&#39;ohai&#39;][&#39;plugin_path&#39;]}/system_node_js.rb&quot; do
  source &quot;plugins/system_node_js.rb.erb&quot;
  owner &quot;root&quot;
  group &quot;root&quot;
  mode 00755
  variables(
    :node_js_bin =&gt; &quot;#{node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;dir&#39;]}/bin/node&quot;
  )
end

include_recipe &quot;ohai&quot;</code></pre> <p>This recipe will generate ohai plugin from <code>system_node_js.rb.erb</code> template. Next we should create this template in folder «templates/default/plugins»:</p> <pre><code>provides &quot;system_node_js&quot;
provides &quot;system_node_js/version&quot;

system_node_js Mash.new unless system_node_js
system_node_js[:version] = nil unless system_node_js[:version]

status, stdout, stderr = run_command(:no_status_check =&gt; true, :command =&gt; &quot;&lt;%= @node_js_bin %&gt; --version&quot;)

system_node_js[:version] = stdout[1..-1] if 0 == status</code></pre> <p>In first two lines we set by method <code>provides</code> automatic attributes, which will provide for us this plugin. Most of the information we want to lookup would be nested in some way, and ohai tends to do this by storing the data in a Mash (similar to Ruby hash type). This can be done by creating a new mash and setting the attribute to it. We did this with <code>system_node_js</code>. In the end of code, plugin set the version of node.js, if node.js installed on node. That’s it!</p> <p>Also we should add new dependency for our cookbook - ohai cookbook:</p> <pre><code>depends &#39;nginx&#39;,           &#39;~&gt; 2.2.0&#39;
depends &#39;build-essential&#39;
depends &#39;ohai&#39;</code></pre> <p>Next, let’s try this plugin by adding node.rb recipe this content:</p> <pre><code>include_recipe &quot;build-essential&quot;

include_recipe &quot;my_cool_app::ohai_plugin&quot;
Chef::Log.info &quot;Installed Node version: #{node[&#39;system_node_js&#39;][&#39;version&#39;]}&quot; if node[&#39;system_node_js&#39;]

case node[&#39;platform_family&#39;]
  when &#39;rhel&#39;,&#39;fedora&#39;
    package &quot;openssl-devel&quot;
  when &#39;debian&#39;
    package &quot;libssl-dev&quot;
end</code></pre> <p>In this case we can little change our node.js recipe:</p> <pre><code>execute &quot;nodejs make install&quot; do
  environment({&quot;PATH&quot; =&gt; &quot;/usr/local/bin:/usr/bin:/bin:$PATH&quot;})
  command &quot;make install&quot;
  cwd &quot;/usr/local/src/node-v#{node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;version&#39;]}&quot;
  not_if {node[&#39;system_node_js&#39;] &amp;&amp; node[&#39;system_node_js&#39;][&#39;version&#39;] == node[&#39;my_cool_app&#39;][&#39;nodejs&#39;][&#39;version&#39;] }
end</code></pre> <p>Now we can check how it works:</p> <pre><code>$ knife cookbook upload my_cool_app
Uploading my_cool_app    [0.1.0]
Uploaded 1 cookbook.

$ vagrant provision chef_second_client
...
INFO: template[/etc/chef/ohai_plugins/system_node_js.rb] created file /etc/chef/ohai_plugins/system_node_js.rb
INFO: template[/etc/chef/ohai_plugins/system_node_js.rb] updated file contents /etc/chef/ohai_plugins/system_node_js.rb
INFO: template[/etc/chef/ohai_plugins/system_node_js.rb] owner changed to 0
INFO: template[/etc/chef/ohai_plugins/system_node_js.rb] group changed to 0
INFO: template[/etc/chef/ohai_plugins/system_node_js.rb] mode changed to 755
...
$ vagrant provision chef_second_client
...
WARN: Current  service[nginx]: /var/chef/cache/cookbooks/nginx/recipes/source.rb:123:in `from_file&#39;
INFO: Installed Node version: 0.10.26
WARN: Cloning resource attributes for package[libssl-dev] from prior resource (CHEF-3694)
...</code></pre> <p>As you can see, after first <code>provision</code> (<code>knife cook</code>, <code>knife ssh 'sudo chef-client'</code>) execution Ohai plugin will be installed, but not executed. Only on second execution chef-client will use Ohai plugin (because Ohai plugins load before running <code>run_list</code>).</p> <h4 id=ohai-7>Ohai 7</h4> <p>Ohai 6 had served us well. However, it had an important architectural limitation that prevented us from implementing some cool ideas, such as differentiating collected data as critical or optional. This limitation was because Ohai 6 treated plugins as monolithic blocks of code.</p> <p>Ohai 7 introduces a new DSL, which makes it easier to write custom plugins, provides better code organization, and sets us up for the future. Here is what an Ohai 7 plugin looks like:</p> <pre><code>Ohai.plugin(:Name) do
  provides &quot;attribute&quot;, &quot;attribute/subattribute&quot;
  depends &quot;kernel&quot;, &quot;users&quot;

  def a_shared_method
    # some Ruby code that defines the shared method
    attribute Mash.new
  end

  collect_data(:default) do
    # some Ruby code
    attribute Mash.new
  end

  collect_data(:windows) do
    # some Ruby code that gets run only on Windows
    attribute Mash.new
  end

end</code></pre> <p>Two important pieces of the new DSL are:</p> <ul> <li><p><code>collect_data()</code> blocks, which enable better organization of platform-specific code</p></li> <li><p><code>depends</code> / <code>provides</code> statements, which enable easier dependency management among plugins</p></li> </ul> <p>Read more about the new DSL <a href="//docs.opscode.com/ohai_custom.html">here</a>.</p> <p>To migrate our plugin on Ohai 7 is very simple:</p> <pre><code>Ohai.plugin(:SystemNodeJs) do
  provides &#39;system_node_js&#39;
  provides &#39;system_node_js/version&#39;

  collect_data do
    system_node_js Mash.new
    system_node_js[:version] = nil unless system_node_js[:version]
    status, stdout, stderr = run_command(:no_status_check =&gt; true, :command =&gt; &quot;&lt;%= @node_js_bin %&gt; --version&quot;)
    system_node_js[:version] = stdout[1..-1] if 0 == status
  end
end</code></pre> <p>Ohai 7 is backwards compatible with existing Ohai 6 plugins. But none of the new (or future) functionality will be available to version 6 plugins. All of your existing plugins will continue to work with Ohai 7.</p> <h2 id=summary-3>Summary</h2> <p>A cookbook is the fundamental unit of configuration and policy distribution. Knowledge of how to write cookbooks is very important to fully use all power of Chef.</p> <h1 id=testing-cookbooks>Testing Cookbooks</h1> <p>Knowing how to write good cookbooks insufficient if its will not be covered by tests. Like in any good software products, cookbook tests avoid bugs, mistakes in code, which is very important. In this chapter we look at the tools that help us test Chef cookbooks.</p> <h2 id="sec:testing-types">Test Types</h2> <p>Exists several types of software testing. Let’s look at some of them.</p> <h3 id=unit-testing>Unit Testing</h3> <p><a href="//en.wikipedia.org/wiki/Unit_testing">Unit testing</a> is a software testing method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures are tested to determine if they are fit for use. Ideally, each test case is independent from the others. Substitutes such as method stubs, mock objects, fakes, and test harnesses can be used to assist testing a module in isolation. Unit tests are typically written and run by software developers to ensure that code meets its design and behaves as intended.</p> <h3 id=integration-testing>Integration Testing</h3> <p><a href="//en.wikipedia.org/wiki/Integration_testing">Integration testing</a> is the phase in software testing in which individual software modules are combined and tested as a group. It occurs after unit testing and before validation testing. Integration testing takes as its input modules that have been unit tested, groups them in larger aggregates, applies tests defined in an integration test plan to those aggregates, and delivers as its output the integrated system ready for system testing.</p> <h3 id=acceptance-testing>Acceptance Testing</h3> <p><a href="//en.wikipedia.org/wiki/Acceptance_testing">Acceptance testing</a>, a testing technique performed to determine whether or not the software system has met the requirement specifications. The main purpose of this test is to evaluate the system’s compliance with the business requirements and verify if it is has met the required criteria for delivery to end users.</p> <h2 id="sec:testing-chefspec">ChefSpec</h2> <p><a href="//code.sethvargo.com/chefspec/">ChefSpec</a> is a unit testing framework for testing Chef cookbooks. ChefSpec makes it easy to write examples and get fast feedback on cookbook changes without the need for virtual machines or cloud servers. ChefSpec using <a href="//rspec.info/">RSpec</a> for writing tests, what is why you should know Rspec at least basic stuff.</p> <h3 id=installing>Installing</h3> <p>Let’s cover our cookbook by chefspec tests. First we should add this gem in Gemfile:</p> <pre><code>source &#39;https://rubygems.org&#39;

gem &#39;berkshelf&#39;
gem &#39;foodcritic&#39;
gem &#39;thor-foodcritic&#39;
gem &#39;chefspec&#39;</code></pre> <p>And you should to execute <code>bundle</code> command to install this gem.</p> <h3 id=testing>Testing</h3> <p>Next we should create config for chefspec:</p> <pre><code>require &#39;chefspec&#39;
require &#39;chefspec/berkshelf&#39; # if you are using librarian, when you should require &#39;chefspec/librarian&#39;

RSpec.configure do |config|
  # Specify the Chef log_level (default: :warn)
  config.log_level = :warn

  # Specify the operating platform to mock Ohai data from (default: nil)
  config.platform = &#39;ubuntu&#39;

  # Specify the operating version to mock Ohai data from (default: nil)
  config.version = &#39;12.04&#39;
end</code></pre> <p>And add some unit tests for default recipe:</p> <pre><code>require &#39;spec_helper&#39;

describe &#39;my_cool_app::default&#39; do
  let(:chef_run) { ChefSpec::Runner.new.converge(described_recipe) }

  %w(git ntp).each do |pack|
    it &quot;install #{pack} package&quot; do
      expect(chef_run).to install_package(pack)
    end
  end

  it &#39;create directory for web app&#39; do
    expect(chef_run).to create_directory(&#39;/var/www/my_cool_app&#39;).with(
      user:   &#39;vagrant&#39;,
      mode:  &quot;0755&quot;
    )
  end

  it &#39;create web app nginx config&#39; do
    expect(chef_run).to create_template(&#39;/etc/nginx/sites-available/my_cool_app.conf&#39;)
  end

  it &#39;enable nginx service&#39; do
    expect(chef_run).to enable_service(&#39;nginx&#39;)
  end

  it &#39;include node recipe&#39; do
    expect(chef_run).to include_recipe(&#39;my_cool_app::node&#39;)
  end

end</code></pre> <p>Now we can check our tests:</p> <pre><code>$ rspec

FFFFFF

Finished in 2.25 seconds
6 examples, 0 failures</code></pre> <p>Our tests failed, because we used <code>nginx_site</code> definition, but dont have nginx service inside our recipe. We can fix this by adding nginx default recipe inside our default recipe (nginx default recipe contain <code>service</code> resource).</p> <pre><code>...

service &#39;nginx&#39; do
  supports :status =&gt; true, :restart =&gt; true, :reload =&gt; true
  action   :start
end</code></pre> <p>You can ask me: «Wait, we already have role <code>nginx</code> inside our node, which install nginx. Does in this case we will call nginx recipe twice?». Yes, your are right. But as you remember, main idea of Chef is idempotence, so on second call of nginx recipe it will do nothing (if recipe written in this way). So we shouldn’t worry about this:</p> <pre><code>...

# nginx recipe
include_recipe &#39;nginx&#39;

# enable website
enable_web_site node[&#39;my_cool_app&#39;][&#39;name&#39;] do
  template &quot;nginx.conf.erb&quot;
end

...</code></pre> <p>Add test for <code>include_recipe</code> call and check tests again:</p> <pre><code>$ rspec

.......

Finished in 2.25 seconds
7 examples, 0 failures</code></pre> <p>As you can see all tests pass.</p> <p>Now let’s cover our node recipe:</p> <pre><code>require &#39;spec_helper&#39;

describe &#39;my_cool_app::node&#39; do
  let(:platform) { &#39;ubuntu&#39; }
  let(:platform_version) { &#39;12.04&#39; }
  let(:chef_run) { ChefSpec::Runner.new(platform: platform, version: platform_version).converge(described_recipe) }
  let(:nodejs_version) { &#39;0.10.26&#39; }
  let(:nodejs_tar) { &quot;node-v#{nodejs_version}.tar.gz&quot; }

  it &quot;install libssl-dev package&quot; do
    expect(chef_run).to install_package(&#39;libssl-dev&#39;)
  end

  context &#39;rhel or fedora&#39; do
    let(:platform) { &#39;redhat&#39; }
    let(:platform_version) { &#39;6.5&#39; }

    it &quot;install openssl-devel package&quot; do
      expect(chef_run).to install_package(&#39;openssl-devel&#39;)
    end
  end

  it &#39;download node if missing&#39; do
    expect(chef_run).to create_remote_file_if_missing(&quot;/usr/local/src/#{nodejs_tar}&quot;)
  end

  it &#39;unpack node&#39; do
    expect(chef_run).to run_execute(&quot;tar --no-same-owner -zxf #{nodejs_tar}&quot;)
  end

  it &#39;install node&#39; do
    expect(chef_run).to run_execute(&#39;make install&#39;).with(cwd: &quot;/usr/local/src/node-v#{nodejs_version}&quot;)
  end
end</code></pre> <p>As you can see, you can pass <code>platform</code> and <code>version</code>, which will be used as Ohai attribute values. This used to check, what depend on <code>platform</code> recipe will install different dependencies. Our results:</p> <pre><code>$ rspec

..........

Finished in 3.19 seconds
12 examples, 0 failures</code></pre> <p>As a result, we covered cookbook by unit tests using chefspec.</p> <h2 id="sec:testing-fauxhai">Fauxhai</h2> <p>Ohai is a tool that is used to detect attributes on a node, and then provide these attributes to the chef-client at the start of every chef-client run. Ohai is required by the chef-client and must be present on a node. It’s awesome, but this can be problem for testing. What is why exist Fauxhai. <a href="//technology.customink.com/fauxhai/">Fauxhai</a> is a gem for mocking out ohai data in your chef testing.</p> <h3 id=testing-1>Testing</h3> <p>As you can see from our node specs, we can set <code>platform</code> and <code>version</code>, but we can stub additional Ohai attribute by using Fauxhai. Let’s look at example:</p> <pre><code>require &#39;chefspec&#39;

describe &#39;my_cool_app::default&#39; do
  [1, 2, 4].each do |kernels|
    context &quot;on Ubuntu with #{kernels} kernels&quot; do
      let(:chef_run) { ChefSpec::ChefRunner.new.converge(described_recipe) }

      before do
        Fauxhai.mock(platform: &#39;ubuntu&#39;, version: &#39;12.04&#39;, fqdn: &#39;example.com&#39;, cpu: { &#39;real&#39; =&gt; kernels, &#39;total&#39; =&gt; kernels })
      end

      it &#39;install htop&#39; do
        expect(chef_run).to install_package(&#39;htop&#39;)
      end

      it &#39;create file /tmp/cpu_count&#39; do
        expect(chef_run).to render_file(&#39;/tmp/cpu_count&#39;).with_content(kernels.to_s)
      end
    end
  end
end</code></pre> <p>As you can see from example, we mock platform, fqdn and cpu numbers from Ohai attributes. And in our recipe we create <code>/tmp/cpu_count</code> file, which contain number of cpu on node. By tests we check what this works on different values of Ohai attributes.</p> <p>Also we can set node attributes by <code>ChefSpec::Runner</code>:</p> <pre><code>...

  context &#39;node versions&#39; do
    let(:system_node_version) { nil }
    let(:chef_run) do
      ChefSpec::Runner.new(platform: platform, version: platform_version) do |node|
        node.automatic[&#39;system_node_js&#39;] = { &#39;version&#39; =&gt; system_node_version } if system_node_version
      end.converge(described_recipe)
    end

    it &#39;install node if version not specified&#39; do
      expect(chef_run).to run_execute(&#39;make install&#39;).with(cwd: &quot;/usr/local/src/node-v#{nodejs_version}&quot;)
    end

    context &#39;installed different version&#39; do
      let(:system_node_version) { &#39;0.8.0&#39; }

      it &#39;install node if version is not the same&#39; do
        expect(chef_run).to run_execute(&#39;make install&#39;).with(cwd: &quot;/usr/local/src/node-v#{nodejs_version}&quot;)
      end
    end

    context &#39;installed same version&#39; do
      let(:system_node_version) { nodejs_version }

      it &#39;do not install node&#39; do
        expect(chef_run).not_to run_execute(&#39;make install&#39;).with(cwd: &quot;/usr/local/src/node-v#{nodejs_version}&quot;)
      end
    end
  end

...</code></pre> <p>And check what this new tests is pass:</p> <pre><code>$ rspec

...............

Finished in 3.76 seconds
15 examples, 0 failures</code></pre> <p>We covered different installation (or not installation) of node.js on node.</p> <h2 id="sec:testing-test-kitchen">Test Kitchen</h2> <p><a href="//kitchen.ci/">Test Kitchen</a> is a test harness tool to execute your configured code on one or more platforms in isolation. A driver plugin architecture is used which lets you run your code on various cloud providers and virtualization technologies such as Amazon EC2, Blue Box, CloudStack, Digital Ocean, Rackspace, OpenStack, Vagrant, Docker, LXC containers, and more. Many testing frameworks are already supported out of the box including Bats, shUnit2, RSpec, Serverspec, etc.</p> <h3 id=installing-1>Installing</h3> <p>Let’s cover our cookbook by test kitchen. First we should add this gem in Gemfile:</p> <pre><code>source &#39;https://rubygems.org&#39;

gem &#39;berkshelf&#39;
gem &#39;foodcritic&#39;
gem &#39;thor-foodcritic&#39;
gem &#39;chefspec&#39;
gem &#39;test-kitchen&#39;
gem &#39;kitchen-vagrant&#39;</code></pre> <p>And you should to execute <code>bundle</code> command to install this gems. We can check what kitchen installed:</p> <pre><code>$ kitchen version
Test Kitchen version 1.2.1
$ kitchen help
Commands:
  kitchen console                         # Kitchen Console!
  kitchen converge [INSTANCE|REGEXP|all]  # Converge one or more instances
  kitchen create [INSTANCE|REGEXP|all]    # Create one or more instances
  kitchen destroy [INSTANCE|REGEXP|all]   # Destroy one or more instances
  kitchen diagnose [INSTANCE|REGEXP|all]  # Show computed diagnostic configuration
  kitchen driver                          # Driver subcommands
  kitchen driver create [NAME]            # Create a new Kitchen Driver gem project
  kitchen driver discover                 # Discover Test Kitchen drivers published on RubyGems
  kitchen driver help [COMMAND]           # Describe subcommands or one specific subcommand
  kitchen help [COMMAND]                  # Describe available commands or one specific command
  kitchen init                            # Adds some configuration to your cookbook so Kitchen can rock
  kitchen list [INSTANCE|REGEXP|all]      # Lists one or more instances
  kitchen login INSTANCE|REGEXP           # Log in to one instance
  kitchen setup [INSTANCE|REGEXP|all]     # Setup one or more instances
  kitchen test [INSTANCE|REGEXP|all]      # Test one or more instances
  kitchen verify [INSTANCE|REGEXP|all]    # Verify one or more instances
  kitchen version                         # Print Kitchen&#39;s version information</code></pre> <p>Now we’ll add Test Kitchen to our project by using the init subcommand:</p> <pre><code>$ kitchen init
    create  .kitchen.yml
    append  Thorfile
    create  test/integration/default</code></pre> <p>What’s going on here? The <code>kitchen init</code> subcommand will create an initial configuration file for Test Kitchen called <code>.kitchen.yml</code>. A few directories were created but these are only a convenience – you don’t strictly need «test/integration/default» in your project. You can see that you have a <code>.gitignore</code> file in your project’s root which will tell Git to never commit a directory called <code>.kitchen</code> and something called <code>.kitchen.local.yml</code>. Finally, a gem called <code>kitchen-vagrant</code> was installed. By itself Test Kitchen can’t do very much. It needs one or more Drivers which are responsible for managing the virtual machines we need for testing. At present there are many different Test Kitchen Drivers but we’re going to stick with the <a href="https://github.com/opscode/kitchen-vagrant">Kitchen Vagrant Driver</a> for now.</p> <p>Let’s turn our attention to the <code>.kitchen.yml</code> file. While Test Kitchen may have created the initial file automatically, it’s expected that you will read and edit this file. Opening this file in your editor of choice we see something like the following:</p> <pre><code>---
driver:
  name: vagrant

provisioner:
  name: chef_solo

platforms:
  - name: ubuntu-12.04
  - name: centos-6.4

suites:
  - name: default
    run_list:
      - recipe[my_cool_app::default]
    attributes:</code></pre> <p>Very briefly we can cover the 4 main sections you’re likely to find in a <code>.kitchen.yml</code> file:</p> <ul> <li><p><code>driver</code>: This is where we configure the behaviour of the Kitchen Driver - the component that is responsible for creating a machine that we’ll use to test our cookbook. Here we set up basics like credentials, ssh usernames, sudo requirements, etc. Each Driver is responsible for requiring and using the configuration here. Under this section we have <code>driver.name</code>: This tells Test Kitchen that we want to use the <code>kitchen-vagrant</code> driver by default unless otherwise specified.</p></li> <li><p><code>provisioner</code>: This tells Test Kitchen how to run Chef, to apply the code in our cookbook to the machine under test. The default and simplest approach is to use <code>chef-solo</code>, but other options are available, and ultimately Test Kitchen doesn’t care how the infrastructure is built - it could theoretically be with Puppet, Ansible, or Perl for all it cares.</p></li> <li><p><code>platforms</code>: This is a list of operation systems on which we want to run our code. Note that the operating system’s version, architecture, cloud environment, etc. might be relevant to what Test Kitchen considers a Platform.</p></li> <li><p><code>suites</code>: This section defines what we want to test. It includes the Chef run-list and any node attribute setups that we want run on each Platform above. For example, we might want to test the MySQL client cookbook code separately from the server cookbook code for maximum isolation.</p></li> </ul> <p>Let’s say for argument’s sake that we only care about running our Chef cookbook on Ubuntu 12.04 distributions. In that case, we can edit the <code>.kitchen.yml</code> file so that the list of platforms has only one entry like so:</p> <pre><code>---
driver:
  name: vagrant

provisioner:
  name: chef_solo

platforms:
  - name: ubuntu-12.04

suites:
  - name: default
    run_list:
      - recipe[my_cool_app::default]
    attributes:</code></pre> <p>To see the results of our work, let’s run the <code>kitchen list</code> subcommand:</p> <pre><code>$ kitchen list
Instance             Driver   Provisioner  Last Action
default-ubuntu-1204  Vagrant  ChefSolo     &lt;Not Created&gt;</code></pre> <p>So what’s this «default-ubuntu-1204» thing and what’s an «Instance»? A Test Kitchen Instance is a pairwise combination of a Suite and a Platform as laid out in your <code>.kitchen.yml</code> file. Test Kitchen has auto-named your only instance by combining the Suite name («default») and the Platform name («ubuntu-12.04») into a form that is safe for DNS and hostname records, namely «default-ubuntu-1204».</p> <p>Okay, let’s spin this Instance up to see what happens. Test Kitchen calls this the Create Action. We’re going to be painfully explicit and ask Test Kitchen to only create the «default-ubuntu-1204» instance:</p> <pre><code>$ kitchen create default-ubuntu-1204
-----&gt; Starting Kitchen (v1.2.1)
-----&gt; Creating &lt;default-ubuntu-1204&gt;...
       Bringing machine &#39;default&#39; up with &#39;virtualbox&#39; provider...
       [default] Importing base box &#39;opscode-ubuntu-12.04&#39;...
       [default] Matching MAC address for NAT networking...
       [default] Setting the name of the VM...
       [default] Clearing any previously set forwarded ports...
       [default] Clearing any previously set network interfaces...
       [default] Preparing network interfaces based on configuration...
       [default] Forwarding ports...
       [default] -- 22 =&gt; 2222 (adapter 1)
       [default] Running &#39;pre-boot&#39; VM customizations...
       [default] Booting VM...
       [default] Waiting for machine to boot. This may take a few minutes...
       [default] Machine booted and ready!
       [default] Setting hostname...
       Vagrant instance &lt;default-ubuntu-1204&gt; created.
       Finished creating &lt;default-ubuntu-1204&gt; (3m56.11s).
-----&gt; Kitchen is finished. (3m57.66s)</code></pre> <p>If you are a Vagrant user then the line containing <code>vagrant up --no-provision</code> will look familiar. Let’s check the status of our instance now:</p> <pre><code>$ kitchen list
Instance             Driver   Provisioner  Last Action
default-ubuntu-1204  Vagrant  ChefSolo     Created</code></pre> <h3 id=running-kitchen-converge>Running Kitchen Converge</h3> <p>Now let’s let Test Kitchen run it for us on our Ubuntu 12.04 instance:</p> <pre><code>$ kitchen converge default-ubuntu-1204
-----&gt; Starting Kitchen (v1.2.1)
-----&gt; Converging &lt;default-ubuntu-1204&gt;...
       Preparing files for transfer
       Resolving cookbook dependencies with Berkshelf 2.0.14...
       Removing non-cookbook files before transfer
       Transfering files to &lt;default-ubuntu-1204&gt;
       ...
       Finished converging &lt;default-ubuntu-1204&gt; (10m24.13s).
-----&gt; Kitchen is finished. (10m26.31s)</code></pre> <p>To quote our Chef run, that was too easy. If you are a Chef user then part of the output above should look familiar to you. Here’s what happened at a high level:</p> <ul> <li><p>Chef was installed on the instance by performing an <a href="//www.opscode.com/chef/install/">Omnibus package installation</a></p></li> <li><p>Your Git cookbook files and a minimal Chef Solo configuration were built and uploaded to the instance</p></li> <li><p>A Chef run was initiated using the run-list and node attributes specified in the <code>.kitchen.yml</code> file</p></li> </ul> <p>There’s nothing to stop you from running this command again (or over-and-over for that matter) so, let’s see what happens:</p> <pre><code>$ kitchen converge default-ubuntu-1204
-----&gt; Starting Kitchen (v1.2.1)
-----&gt; Converging &lt;default-ubuntu-1204&gt;...
       Preparing files for transfer
       Resolving cookbook dependencies with Berkshelf 2.0.14...
       Removing non-cookbook files before transfer
       Transfering files to &lt;default-ubuntu-1204&gt;
       ...
       Finished converging &lt;default-ubuntu-1204&gt; (0m13.13s).
-----&gt; Kitchen is finished. (0m15.23s)</code></pre> <p>That ran a lot faster didn’t it? Here’s what happened this time:</p> <ul> <li><p>Test Kitchen found that Chef was present and installed so skipped a re-installation.</p></li> <li><p>The same Chef cookbook files and Chef Solo configuration was uploaded to the instance. Test Kitchen is optimizing for freshness of code and configuration over speed. Although we all like speed wherever possible.</p></li> <li><p>A Chef run is initiated and runs very quickly as we are in the desired state.</p></li> </ul> <p>Let’s check the status of our instance:</p> <pre><code>$ kitchen list
Instance             Driver   Provisioner  Last Action
default-ubuntu-1204  Vagrant  ChefSolo     Converged</code></pre> <p>A clean converge run, success!</p> <h3 id=manually-verifying>Manually Verifying</h3> <p>Test Kitchen has a <code>login</code> subcommand for just these kinds of situations:</p> <pre><code>$ kitchen login default-ubuntu-1204
Welcome to Ubuntu 12.04.3 LTS (GNU/Linux 3.8.0-29-generic x86_64)

 * Documentation:  https://help.ubuntu.com/
Last login: Thu Mar  6 22:01:08 2014 from 10.0.2.2
vagrant@default-ubuntu-1204:~$ ps ax | grep nginx
 6151 ?        Ss     0:00 nginx: master process /usr/sbin/nginx
26282 ?        S      0:00 nginx: worker process
26758 pts/0    S+     0:00 grep --color=auto nginx</code></pre> <p>As you can see by the prompt above we are now in the «default-ubuntu-1204» instance and nginx installed inside it.</p> <h3 id=writing-a-test>Writing a Test</h3> <p>Now if you are interested in writing some tests, Test Kitchen has several options available to you. The component that helps facilitate testing on your instances is called Busser. Just like Test Kitchen it is a RubyGem library and it provides a plugin system so that you can wire in whatever testing framework your heart desires. A quick <a href="https://rubygems.org/search?utf8=%E2%9C%93&amp;amp;query=busser-">search</a> on the RubyGems website returns several testing frameworks currently available to you.</p> <p>To keep things simple we’re going to use the <code>busser-bats</code> runner plugin which uses the <a href="https://github.com/sstephenson/bats">Bash Automated Testing System</a> also known as bats.</p> <p>We need to put our test files in a specific location, so let’s create the directory:</p> <pre><code>$ mkdir -p test/integration/default/bats</code></pre> <p>It looks long and dense, but each directory has some meaning to Test Kitchen and the Busser helper:</p> <ul> <li><p><code>test/integration</code>: Test Kitchen will look for tests to run under this directory. It allows you to put unit or other tests in test/unit, spec, acceptance, or wherever without mixing them up. This is configurable, if desired.</p></li> <li><p><code>default</code>: This corresponds exactly to the Suite name we set up in the .kitchen.yml file. If we had a suite called «server-only», then you would put tests for the server only suite under test/integration/server-only.</p></li> <li><p><code>bats</code>: This tells Test Kitchen (and Busser) which Busser runner plugin needs to be installed on the remote instance. In other words the bats directory name will cause Busser to install busser-bats from RubyGems.</p></li> </ul> <p>Let’s write a test. Create a new file called <code>test/integration/default/bats/nginx_installed.bats</code> with the following:</p> <pre><code>#!/usr/bin/env bats

@test &quot;nginx binary is found in PATH&quot; {
  run which nginx
  [ &quot;$status&quot; -eq 0 ]
}</code></pre> <p>Now to put our test to the test. For this we’ll use the verify subcommand:</p> <pre><code>$ kitchen verify default-ubuntu-1204
-----&gt; Starting Kitchen (v1.2.1)
-----&gt; Setting up &lt;default-ubuntu-1204&gt;...
Fetching: thor-0.18.1.gem (100%)
Fetching: busser-0.6.0.gem (100%)
...
Uploading /tmp/busser/suites/bats/nginx_installed.bats (mode=0755)
-----&gt; Running bats test suite
  nginx binary is found in PATH

       1 test, 0 failures
       Finished verifying &lt;default-ubuntu-1204&gt; (0m1.39s).
-----&gt; Kitchen is finished. (0m16.51s)</code></pre> <p>All right!</p> <p>A few things of note from the output above:</p> <ul> <li><p>Notice the Setting up «default-ubuntu-1204» line? That’s another action called the Setup Action. Usually not a big for most users but this action is responsible for installing the Busser RubyGem and any test runner plugins required. In our case the busser-bats RubyGem was installed which helped to install the bats testing framework.</p></li> <li><p>The Verifying «default-ubuntu-1204» line corresponds to the start of the Verify Action and the nginx binary is found in PATH line is output from a bats test run.</p></li> <li><p>The last command (<code>echo \$?</code>) is a way to print the exit code of the last run shell command. This shows that the kitchen command exited cleanly.</p></li> </ul> <p>Let’s check the status of our instance again:</p> <pre><code>$ kitchen list
Instance             Driver   Provisioner  Last Action
default-ubuntu-1204  Vagrant  ChefSolo     Verified</code></pre> <p>Let’s add more tests:</p> <pre><code>@test &quot;nginx config is valid&quot; {
  run sudo nginx -t
  [ &quot;$status&quot; -eq 0 ]
}

@test &quot;nginx is running&quot; {
  run service nginx status
  [ &quot;$status&quot; -eq 0 ]
  [ &quot;$output&quot; == &quot; * nginx is running&quot; ]
}</code></pre> <h3 id=running-kitchen-test>Running Kitchen Test</h3> <p>Now it’s time to introduce to the <code>test</code> meta-action which helps you automate all the previous actions so far into one command. Recall that we currently have our instance in a «verified» state. With this in mind, let’s run kitchen test:</p> <pre><code>$ kitchen test default-ubuntu-1204
-----&gt; Starting Kitchen (v1.2.1)
-----&gt; Cleaning up any prior instances of &lt;default-ubuntu-1204&gt;
-----&gt; Destroying &lt;default-ubuntu-1204&gt;...
       Finished destroying &lt;default-ubuntu-1204&gt; (0m0.00s).
-----&gt; Testing &lt;default-ubuntu-1204&gt;
...
Uploading /tmp/busser/suites/bats/nginx_installed.bats (mode=0755)
-----&gt; Running bats test suite
  nginx binary is found in PATH

       1 test, 0 failures
       Finished verifying &lt;default-ubuntu-1204&gt; (0m1.39s).
-----&gt; Kitchen is finished. (0m16.51s)</code></pre> <p>There’s only one remaining action left that needs a mention: the Destroy Action which destroys the instance. With this in mind, here’s what Test Kitchen is doing in the Test Action:</p> <ul> <li><p>Destroys the instance if it exists (<code>Cleaning up any prior instances of &lt;default-ubuntu-1204&gt;</code>)</p></li> <li><p>Creates the instance (<code>Creating &lt;default-ubuntu-1204&gt;</code>)</p></li> <li><p>Converges the instance (<code>Converging &lt;default-ubuntu-1204&gt;</code>)</p></li> <li><p>Sets up Busser and runner plugins on the instance (<code>Setting up &lt;default-ubuntu-1204&gt;</code>)</p></li> <li><p>Verifies the instance by running Busser tests (<code>Verifying &lt;default-ubuntu-1204&gt;</code>)</p></li> <li><p>Destroys the instance (<code>Destroying &lt;default-ubuntu-1204&gt;</code>)</p></li> </ul> <p>A few details with regards to test:</p> <ul> <li><p>Test Kitchen will abort the run on the instance at the first sign of trouble. This means that if your Chef run fails then Busser won’t be installed and the instance won’t be destroyed. This gives you a chance to inspect the state of the instance and fix any issues.</p></li> <li><p>The behavior of the final destroy action can be overridden if desired. Check out the documentation for the <code>--destroy</code> flag using <code>kitchen help test</code>.</p></li> <li><p>The primary use case in mind for this meta-action is in a Continuous Integration environment or a command for developers to run before check in or after a fresh clone. If you’re using this in your test-code-verify development cycle it’s going to quickly become very slow and frustrating. You’re better off running the <code>converge</code> and <code>verify</code> subcommands in development and save the test subcommand when you need to verify the end-to-end run of your code.</p></li> </ul> <p>Finally, let’s check the status of the instance:</p> <pre><code>$ kitchen list
Instance             Driver   Provisioner  Last Action
default-ubuntu-1204  Vagrant  ChefSolo     &lt;Not Created&gt;</code></pre> <h3 id=adding-a-platform>Adding a Platform</h3> <p>Now that we are masters of the Ubuntu platform, let’s add support for CentOS to our cookbook. This shouldn’t be too bad. Open <code>.kitchen.yml</code> in your editor and the <code>centos-6.4</code> line to your platforms list so that it resembles:</p> <pre><code>---
driver:
  name: vagrant

provisioner:
  name: chef_solo

platforms:
  - name: ubuntu-12.04
  - name: centos-6.4

suites:
  - name: default
    run_list:
      - recipe[my_cool_app::default]
    attributes:</code></pre> <p>Now let’s check the status of our instances:</p> <pre><code>$ kitchen list
Instance             Driver   Provisioner  Last Action
default-ubuntu-1204  Vagrant  Chef Solo    &lt;Not Created&gt;
default-centos-64    Vagrant  Chef Solo    &lt;Not Created&gt;</code></pre> <p>We’re going to use two shortcuts here in the next command:</p> <ul> <li><p>Each Test Kitchen instance has a simple state machine that tracks where it is in its lifecycle. Given its current state and the desired state, the instance is smart enough to run all actions in between current and desired. In our next example we will take an instance from not created to verified in one command.</p></li> <li><p>Any <code>kitchen</code> subcommand that takes an instance name as an argument can take a Ruby regular expression that will be used to glob a list of instances together. This means that <code>kitchen test ubuntu</code> would run the test action only the ubuntu instance. Note that the list subcommand also takes the regex-globbing argument so feel free to experiment there. In our next example we’ll select the <code>default-centos-64</code> instance with simply <code>64</code>.</p></li> </ul> <p>Let’s see how CentOS runs our cookbook:</p> <pre><code>$ kitchen verify 64
-----&gt; Starting Kitchen (v1.2.1)
-----&gt; Creating &lt;default-centos-64&gt;...
...
-----&gt; Running bats test suite
   nginx binary is found in PATH
   nginx config is valid                                                    2/3
   nginx config is valid
   nginx is running                                                         3/3
   nginx is running
          (in test file /tmp/busser/suites/bats/nginx_installed.bats, line 16)

       3 tests, 1 failure</code></pre> <p>We should fix failed test:</p> <pre><code>@test &quot;nginx is running&quot; {
   run service nginx status
   [ &quot;$status&quot; -eq 0 ]
-  [ &quot;$output&quot; == &quot; * nginx is running&quot; ]
+  [ $(expr &quot;$output&quot; : &quot;.*nginx.*running&quot;) -ne 0 ]
}</code></pre> <p>And check again on all instances:</p> <pre><code>$ kitchen verify
-----&gt; Starting Kitchen (v1.2.1)
-----&gt; Creating &lt;default-centos-64&gt;...
...
-----&gt; Verifying &lt;default-ubuntu-1204&gt;...
       Suite path directory /tmp/busser/suites does not exist, skipping.
Uploading /tmp/busser/suites/bats/nginx_installed.bats (mode=0755)
-----&gt; Running bats test suite
   nginx binary is found in PATH
   nginx config is valid
   nginx is running

3 tests, 0 failures
       Finished verifying &lt;default-ubuntu-1204&gt; (0m1.46s).
-----&gt; Verifying &lt;default-centos-64&gt;...
       Removing /tmp/busser/suites/bats
       Uploading /tmp/busser/suites/bats/nginx_installed.bats (mode=0755)
-----&gt; Running bats test suite
   nginx binary is found in PATH
   nginx config is valid                                                    2/3
   nginx config is valid
   nginx is running                                                         3/3
   nginx is running

       3 tests, 0 failures
       Finished verifying &lt;default-centos-64&gt; (0m1.81s).</code></pre> <p>Nice! We’ve verified that our cookbook works on Ubuntu 12.04 and CentOS 6.4. Since the CentOS instance will hang out for no good reason, let’s kill it for now:</p> <pre><code>$ kitchen destroy
-----&gt; Starting Kitchen (v1.2.1)
-----&gt; Destroying &lt;default-ubuntu-1204&gt;...
       ...
       Finished destroying &lt;default-ubuntu-1204&gt; (0m5.82s).
-----&gt; Destroying &lt;default-centos-64&gt;...
       ...
       Finished destroying &lt;default-centos-64&gt; (0m5.41s).
-----&gt; Kitchen is finished. (0m12.95s)</code></pre> <p>Any <code>kitchen</code> subcommand without an instance argument will apply to all instances.</p> <h3 id=fixing-converge>Fixing Converge</h3> <p>Now a colleague has expressed interest in running the cookbook on a fleet of older Ubuntu 10.04 systems. Open <code>.kitchen.yml</code> in your editor and add a <code>ubuntu-10.04</code> entry to the platforms list:</p> <pre><code>---
driver:
  name: vagrant

provisioner:
  name: chef_solo

platforms:
  - name: ubuntu-12.04
  - name: ubuntu-10.04
  - name: centos-6.4

suites:
  - name: default
    run_list:
      - recipe[my_cool_app::default]
    attributes:</code></pre> <p>And run <code>kitchen list</code> to confirm the introduction of our latest instance:</p> <pre><code>$ kitchen list
Instance             Driver   Provisioner  Last Action
default-ubuntu-1204  Vagrant  ChefSolo     &lt;Not Created&gt;
default-ubuntu-1004  Vagrant  ChefSolo     &lt;Not Created&gt;
default-centos-64    Vagrant  ChefSolo     &lt;Not Created&gt;</code></pre> <p>Now we’ll run the <code>test</code> subcommand and go grab a coffee:</p> <pre><code>$ kitchen test 10
-----&gt; Starting Kitchen (v1.2.1)
-----&gt; Cleaning up any prior instances of &lt;default-ubuntu-1004&gt;
-----&gt; Destroying &lt;default-ubuntu-1004&gt;...
       Finished destroying &lt;default-ubuntu-1004&gt; (0m0.00s).
-----&gt; Testing &lt;default-ubuntu-1004&gt;
...
Chef::Exceptions::Package
       -------------------------
       git has no candidate in the apt-cache</code></pre> <p>Oh noes! Argh, why!? Let’s login to the instance and see if we can figure out what the correct package is:</p> <pre><code>$  kitchen login 10

vagrant@default-ubuntu-1004:~$ sudo apt-cache search git | grep ^git
git-buildpackage - Suite to help with Debian packages in Git repositories
git-cola - highly caffeinated git gui
git-load-dirs - Import upstream archives into git
gitg - git repository viewer for gtk+/GNOME
gitmagic - guide about Git version control system
gitosis - git repository hosting application
gitpkg - tools for maintaining Debian packages with git
gitstats - statistics generator for git repositories
git-core - fast, scalable, distributed revision control system
git-doc - fast, scalable, distributed revision control system (documentation)
gitk - fast, scalable, distributed revision control system (revision tree visualizer)
git-arch - fast, scalable, distributed revision control system (arch interoperability)
git-cvs - fast, scalable, distributed revision control system (cvs interoperability)
git-daemon-run - fast, scalable, distributed revision control system (git-daemon service)
git-email - fast, scalable, distributed revision control system (email add-on)
git-gui - fast, scalable, distributed revision control system (GUI)
git-svn - fast, scalable, distributed revision control system (svn interoperability)
gitweb - fast, scalable, distributed revision control system (web interface)</code></pre> <p>Okay, it looks like we want to install the <code>git-core</code> package for this release of Ubuntu. Let’s fix this up back in the default recipe. Open up <code>recipes/default.rb</code> and edit to something like:</p> <pre><code># install needed package
packages = %w(ntp)

if &quot;ubuntu&quot; == node[&#39;platform&#39;] &amp;&amp; node[&#39;platform_version&#39;].to_f &lt;= 10.04
  packages « &quot;git-core&quot;
else
  packages « &quot;git&quot;
end

packages.each do |pack|
  package pack
end</code></pre> <p>This may not be pretty but let’s verify that it works first on Ubuntu 10.04:</p> <pre><code>$ kitchen verify 10
...
-----&gt; Running bats test suite
   nginx binary is found in PATH
   nginx config is valid                                                    2/3
   nginx config is valid
   nginx is running                                                         3/3
   nginx is running

       3 tests, 0 failures
       Finished verifying &lt;default-ubuntu-1004&gt; (0m2.51s).
-----&gt; Kitchen is finished. (0m53.48s)</code></pre> <p>Back to green, good. Let’s verify that the all instances are still good.</p> <pre><code>$ kitchen verify -c 3
-----&gt; Starting Kitchen (v1.2.1)
-----&gt; Verifying &lt;default-centos-64&gt;...
-----&gt; Verifying &lt;default-ubuntu-1004&gt;...
-----&gt; Verifying &lt;default-ubuntu-1204&gt;...
       Removing /tmp/busser/suites/bats
       Removing /tmp/busser/suites/bats
       Uploading /tmp/busser/suites/bats/nginx_installed.bats (mode=0755)
Uploading /tmp/busser/suites/bats/nginx_installed.bats (mode=0755)
       Removing /tmp/busser/suites/bats
       Uploading /tmp/busser/suites/bats/nginx_installed.bats (mode=0755)
-----&gt; Running bats test suite
 -----&gt; Running bats test suite                                             1/3
   nginx binary is found in PATH
   nginx config is valid                                                    2/3
   nginx config is valid
   nginx is running                                                         3/3
   nginx is running

       3 tests, 0 failures
        Finished verifying &lt;default-ubuntu-1004&gt; (0m2.94s).                 1/3
   nginx binary is found in PATH
   nginx config is valid
   nginx is running

       3 tests, 0 failures
       Finished verifying &lt;default-ubuntu-1204&gt; (0m3.09s).
-----&gt; Running bats test suite
   nginx binary is found in PATH
   nginx config is valid                                                    2/3
   nginx config is valid
   nginx is running                                                         3/3
   nginx is running

       3 tests, 0 failures
       Finished verifying &lt;default-centos-64&gt; (0m3.86s).
-----&gt; Kitchen is finished. (0m6.12s)</code></pre> <p>We used <code>-c</code> to run a test against all matching instances concurrently, where next argument mean number of instances run at the same time.</p> <p>We’ve successfully verified all three instances, so let’s shut them down.</p> <pre><code>$ kitchen destroy
-----&gt; Starting Kitchen (v1.2.1)
...
-----&gt; Kitchen is finished. (0m19.86s)</code></pre> <h3 id=adding-a-suite>Adding a Suite</h3> <p>We’re going to call our new Test Kitchen Suite «node» by opening <code>.kitchen.yml</code> in your editor of choice so that it looks similar to:</p> <pre><code>---
driver:
  name: vagrant

provisioner:
  name: chef_solo

platforms:
  - name: ubuntu-12.04
  - name: ubuntu-10.04
  - name: centos-6.4

suites:
  - name: default
    run_list:
      - recipe[my_cool_app::default]
    attributes:
  - name: node
    run_list:
      - recipe[my_cool_app::default]
      - recipe[my_cool_app::node]
    attributes:</code></pre> <p>Now run <code>kitchen list</code> to see our new suite in action:</p> <pre><code>$ kitchen list
Instance             Driver   Provisioner  Last Action
default-ubuntu-1204  Vagrant  ChefSolo     &lt;Not Created&gt;
default-ubuntu-1004  Vagrant  ChefSolo     &lt;Not Created&gt;
default-centos-64    Vagrant  ChefSolo     &lt;Not Created&gt;
node-ubuntu-1204     Vagrant  ChefSolo     &lt;Not Created&gt;
node-ubuntu-1004     Vagrant  ChefSolo     &lt;Not Created&gt;
node-centos-64       Vagrant  ChefSolo     &lt;Not Created&gt;</code></pre> <h3 id=writing-a-server-test>Writing a Server Test</h3> <p>Now to write a test or two. Previously we’ve seen the bats testing framework in action but this isn’t always a viable option. For example if you needed to verify that a package was installed and you needed to test that on Ubuntu and CentOS platforms, then what would you do? You need to bust out some platform detection in order to run a Debian or RPM-based command. Feels like Chef would help us here since it’s good at that sort of thing. On the other hand there are advantages to treating our Chef run as a black box - a configuration-management implementation detail, if you will. So what to do?</p> <p>A nice solution to the platform-agnostic test issue exists called <a href="//serverspec.org/">ServerSpec</a>. It is a set of RSpec matchers that can assert things about servers like packages installed, services enabled, ports listening, etc. Let’s see what this looks like for our Git Daemon tests.</p> <p>First we’re going to create a directory for our test file:</p> <pre><code>$ mkdir -p test/integration/node/serverspec</code></pre> <p>Next, create a file called <code>test/integration/server/serverspec/nginx_daemon_spec.rb</code> with the following:</p> <pre><code>require &#39;serverspec&#39;

include Serverspec::Helper::Exec
include Serverspec::Helper::DetectOS

RSpec.configure do |c|
  c.before :all do
    c.path = &#39;/sbin:/usr/sbin&#39;
  end
end

describe &quot;Nginx Daemon&quot; do

  it &quot;is listening on port 80&quot; do
    expect(port(80)).to be_listening
  end

  it &quot;has a running service of git-daemon&quot; do
    expect(service(&quot;nginx&quot;)).to be_running
  end

end</code></pre> <p>And <code>test/integration/server/serverspec/node_spec.rb</code> with the following:</p> <pre><code>require &#39;serverspec&#39;

include Serverspec::Helper::Exec
include Serverspec::Helper::DetectOS

RSpec.configure do |c|
  c.before :all do
    c.path = &#39;/sbin:/usr/sbin:/usr/local/bin&#39;
  end
end

describe &quot;Node&quot; do

  describe command(&#39;node -v&#39;) do
    it { should return_stdout &#39;v0.10.26&#39; }
  end

end</code></pre> <p>As our primary target platform was Ubuntu 12.04, we’ll target this one first for development. Now, in Test-Driven style we’ll run <code>kitchen verify</code> to watch our tests fail spectacularly:</p> <pre><code>$ kitchen verify node-ubuntu-1204
-----&gt; Starting Kitchen (v1.2.1)
-----&gt; Creating &lt;node-ubuntu-1204&gt;...
...

Nginx Daemon
  is listening on port 80
  has a running service of git-daemon

       Node
         Command &quot;node -v&quot;

    should return stdout &quot;v0.10.26&quot;

Finished in 0.22341 seconds
3 examples, 0 failures
       Finished verifying &lt;node-ubuntu-1204&gt; (0m2.78s).
-----&gt; Kitchen is finished. (13m29.49s)</code></pre> <p>One quick check of <code>kitchen list</code> tells us that our instance was created by not successfully converged:</p> <pre><code>$ kitchen list
Instance             Driver   Provisioner  Last Action
default-ubuntu-1204  Vagrant  ChefSolo     &lt;Not Created&gt;
default-ubuntu-1004  Vagrant  ChefSolo     &lt;Not Created&gt;
default-centos-64    Vagrant  ChefSolo     &lt;Not Created&gt;
node-ubuntu-1204     Vagrant  ChefSolo     Verified
node-ubuntu-1004     Vagrant  ChefSolo     &lt;Not Created&gt;
node-centos-64       Vagrant  ChefSolo     &lt;Not Created&gt;</code></pre> <p>Yes, you can specify one or more instances with the same Ruby regular expression globbing as any other kitchen subcommands. Let’s see if our server recipe works on the all platforms (Ubuntu 10.04 and CentOS 6.4). Fingers crossed, here we go:</p> <pre><code>$ kitchen verify node
-----&gt; Starting Kitchen (v1.2.1)
-----&gt; Verifying &lt;node-ubuntu-1204&gt;...
...

Nginx Daemon
  is listening on port 80
  has a running service of git-daemon

Node
  Command &quot;node -v&quot;
    should return stdout &quot;v0.10.26&quot;

Finished in 0.09353 seconds
3 examples, 0 failures
       Finished verifying &lt;node-ubuntu-1204&gt; (0m2.41s).
-----&gt; Verifying &lt;node-ubuntu-1004&gt;...
...

       Nginx Daemon
         is listening on port 80
         has a running service of git-daemon

       Node
         Command &quot;node -v&quot;
           should return stdout &quot;v0.10.26&quot;

       Finished in 0.08732 seconds
       3 examples, 0 failures
       Finished verifying &lt;node-ubuntu-1004&gt; (0m2.34s).
-----&gt; Verifying &lt;node-centos-64&gt;...
...
       Nginx Daemon
         is listening on port 80
         has a running service of git-daemon

       Node
         Command &quot;node -v&quot;
           should return stdout &quot;v0.10.26&quot;

       Finished in 0.12761 seconds
       3 examples, 0 failures
       Finished verifying &lt;node-centos-64&gt; (0m3.11s).
-----&gt; Kitchen is finished. (0m9.27s)</code></pre> <p>If for example, you don’t want support some platform, you can use <code>excludes</code> key in <code>.kitchen.yml</code> file:</p> <pre><code>---
driver:
  name: vagrant

provisioner:
  name: chef_solo

platforms:
  - name: ubuntu-12.04
  - name: ubuntu-10.04
  - name: centos-6.4

suites:
  - name: default
    run_list:
      - recipe[my_cool_app::default]
    attributes:
  - name: node
    run_list:
      - recipe[my_cool_app::default]
      - recipe[my_cool_app::node]
    attributes:
    excludes:
      - centos-6.4</code></pre> <p>Now let’s run kitchen list to ensure the instance is gone:</p> <pre><code>$ kitchen list
Instance             Driver   Provisioner  Last Action
default-ubuntu-1204  Vagrant  ChefSolo     &lt;Not Created&gt;
default-ubuntu-1004  Vagrant  ChefSolo     &lt;Not Created&gt;
default-centos-64    Vagrant  ChefSolo     &lt;Not Created&gt;
node-ubuntu-1204     Vagrant  ChefSolo     Verified
node-ubuntu-1004     Vagrant  ChefSolo     Verified</code></pre> <h2 id="sec:testing-chef-zero">Chef Zero</h2> <p>Chef Zero is a simple, easy-install, in-memory Chef server that can be useful for Chef Client testing and chef-solo-like tasks that require a full Chef Server. It IS intended to be simple, Chef 11 compliant, easy to run and fast to start. It is NOT intended to be secure, scalable, performant or persistent. It does NO input validation, authentication or authorization (it will not throw a 400, 401 or 403). It does not save data, and will start up empty each time you start it.</p> <p>Because Chef Zero runs in memory, it’s super fast and lightweight. This makes it perfect for testing against a «real» Chef Server without mocking the entire Internet.</p> <h3 id=installing-2>Installing</h3> <p>Let’s cover our cookbook by using Chef Zero. First we should add this gem in Gemfile:</p> <pre><code>source &#39;https://rubygems.org&#39;

gem &#39;berkshelf&#39;
gem &#39;foodcritic&#39;
gem &#39;thor-foodcritic&#39;
gem &#39;chefspec&#39;
gem &#39;test-kitchen&#39;
gem &#39;kitchen-vagrant&#39;
gem &#39;chef-zero&#39;</code></pre> <p>And you should to execute <code>bundle</code> command to install this gem. We can check what Chef Zero installed:</p> <pre><code>$ chef-zero
» Starting Chef Zero (v1.7.3)...
» Puma (v1.6.3) is listening at http://127.0.0.1:8889
» Press CTRL+C to stop
^C
» Stopping Chef Zero ...</code></pre> <p>Command <code>chef-zero</code> start Chef Zero server in foreground. This is fully functional (empty) Chef Server. To use it in your own repository, create a <code>knife.rb</code> like so:</p> <pre><code>chef_server_url   &#39;http://127.0.0.1:8889&#39;
node_name         &#39;stickywicket&#39;
client_key        &#39;path_to_any_pem_file.pem&#39;</code></pre> <p>And use knife like you normally would.</p> <p>Since Chef Zero does no authentication, any <code>.pem</code> file will do. The client just needs something to sign requests with (which will be ignored on the server). Even though it’s ignored, the <code>.pem</code> must still be a valid format.</p> <p>If you will stop the Chef Zero server than all the data is gone.</p> <p>Run <code>chef-zero --help</code> to see a list of the supported flags and options:</p> <pre><code>$ chef-zero --help
Usage: chef-zero [ARGS]
    -H, --host HOST                  Host to bind to (default: 127.0.0.1)
    -p, --port PORT                  Port to listen on
        --socket PATH                Unix socket path to listen on
        --[no-]generate-keys         Whether to generate actual keys or fake it (faster).  Default: false.
    -d, --daemon                     Run as a daemon process
    -l, --log-level LEVEL            Set the output log level
    -h, --help                       Show this message
        --version                    Show version</code></pre> <h3 id=using-with-chefspec>Using with ChefSpec</h3> <p>By default, ChefSpec runs in Chef Solo mode, but you can ask ChefSpec to create an in-memory Chef Server during testing using ChefZero. This is especially helpful if you need to support searching or data bags.</p> <p>To use the ChefSpec server, simply require the module in your <code>spec_helper</code>:</p> <pre><code># spec_helper.rb
require &#39;chefspec&#39;
require &#39;chefspec/server&#39;</code></pre> <p>This will automatically create a Chef server, synchronize all the cookbooks in your <code>cookbook_path</code>, and wire all the internals of Chef together. Recipe calls to <code>search</code>, <code>data_bag</code> and <code>data_bag_item</code> will now query the ChefSpec server.</p> <p>The ChefSpec server includes a collection of helpful DSL methods for populating data into the Chef Server.</p> <p>Create a client:</p> <pre><code>ChefSpec::Server.create_client(&#39;my_client&#39;, { admin: true })</code></pre> <p>Create a data bag (and items):</p> <pre><code>ChefSpec::Server.create_data_bag(&#39;my_data_bag&#39;, {
  &#39;item_1&#39; =&gt; {
    &#39;password&#39; =&gt; &#39;abc123&#39;
  },
  &#39;item_2&#39; =&gt; {
    &#39;password&#39; =&gt; &#39;def456&#39;
  }
})</code></pre> <p>Create an environment:</p> <pre><code>ChefSpec::Server.create_environment(&#39;my_environment&#39;, { description: &#39;...&#39; })</code></pre> <p>Create a node:</p> <pre><code>ChefSpec::Server.create_node(&#39;my_node&#39;, { run_list: [&#39;...&#39;] })</code></pre> <p>You may also be interested in the <code>stub_node</code> macro, which will create a new <code>Chef::Node</code> object and accepts the same parameters as the Chef Runner and a Fauxhai object:</p> <pre><code>www = stub_node(platform: &#39;ubuntu&#39;, version: &#39;12.04&#39;) do |node|
  node.set[&#39;attribute&#39;] = &#39;value&#39;
end

# `www` is now a local Chef::Node object you can use in your test. To push this
# node to the server, call `create_node`:

ChefSpec::Server.create_node(www)</code></pre> <p>Create a role:</p> <pre><code>ChefSpec::Server.create_role(&#39;my_role&#39;, { default_attributes: {} })

# The role now exists on the Chef Server, you can add it to a node&#39;s run_list
# by adding it to the `converge` block:
let(:chef_run) { ChefSpec::Runner.new.converge(described_recipe, &#39;role[my_role]&#39;) }</code></pre> <h4 id=example-3>Example</h4> <p>Let’s create recipe <code>haproxy</code> in our cookbook:</p> <pre><code># install and setup haproxy

package &quot;haproxy&quot;

# get nodes of some roles
if Chef::Config[:solo]
  Chef::Log.warn(&quot;This recipe uses search. Chef Solo does not support search.&quot;)
  pool_members = []
else
  pool_members = search(&quot;node&quot;, &quot;role:#{node[&#39;my_cool_app&#39;][&#39;haproxy&#39;][&#39;app_server_role&#39;]} AND chef_environment:#{node.chef_environment}&quot;) || []
end

pool_members.map! do |member|
  {:ipaddress =&gt; member[&#39;ipaddress&#39;], :hostname =&gt; member[&#39;hostname&#39;]}
end

if pool_members.length &gt; 0

  http_clients = pool_members.uniq.map do |s|
    &quot;server #{s[:hostname]} #{s[:ipaddress]}:80 weight 1 maxconn 1024 check&quot;
  end
  http_clients = [&quot;mode http&quot;] + http_clients + [&quot;option httpchk GET /healthcheck&quot;]

  https_clients = pool_members.uniq.map do |s|
    &quot;server #{s[:hostname]} #{s[:ipaddress]}:443 weight 1 maxconn 1024 check&quot;
  end
  https_clients = [&quot;mode http&quot;] + https_clients + [&quot;option httpchk GET /ssl-healthcheck&quot;]

else

  http_clients = https_clients = []

end

listeners = {
  &quot;listen&quot; =&gt; {},
  &quot;frontend&quot; =&gt; {
    &quot;ft_http&quot; =&gt; [
      &quot;bind *:80&quot;,
      &quot;mode tcp&quot;,
      &quot;default_backend bk_http&quot;
    ],
    &quot;ft_https&quot; =&gt; [
      &quot;bind *:443&quot;,
      &quot;mode tcp&quot;,
      &quot;default_backend bk_https&quot;
    ]
  },
  &quot;backend&quot; =&gt; {
    &quot;bk_http&quot; =&gt; http_clients,
    &quot;bk_https&quot; =&gt; https_clients
  }
}

template &quot;/etc/haproxy/haproxy.cfg&quot; do
  source &quot;haproxy.cfg.erb&quot;
  owner &quot;root&quot;
  group &quot;root&quot;
  mode 00644
  notifies :reload, &quot;service[haproxy]&quot;
  variables(
    :listeners =&gt; listeners
  )
end

cookbook_file &#39;/etc/default/haproxy&#39; do
  source &#39;haproxy-default&#39;
  owner &#39;root&#39;
  group &#39;root&#39;
  mode 00644
  notifies :restart, &#39;service[haproxy]&#39;
end

service &quot;haproxy&quot; do
  supports :restart =&gt; true, :status =&gt; true, :reload =&gt; true
  action [:enable, :start]
end</code></pre> <p>And default attributes for it:</p> <pre><code>default[&#39;my_cool_app&#39;][&#39;haproxy&#39;][&#39;app_server_role&#39;]       = &#39;web&#39;</code></pre> <p>In our recipe used template <code>haproxy.cfg.erb</code>:</p> <pre><code>global
  log 127.0.0.1   local0
  log 127.0.0.1   local1 notice
  maxconn 5000
  user haproxy
  group haproxy

defaults
  log     global
  mode    http
  retries 3
  timeout client 60000
  timeout server 50000
  timeout connect 25000
  balance roundrobin

&lt;% @listeners.each do |type, listeners | %&gt;
&lt;% listeners.each do |name, listen| %&gt;
&lt;%= type %&gt; &lt;%= name %&gt;
&lt;% listen.each do |option| %&gt;
  &lt;%= option %&gt;
&lt;% end %&gt;
&lt;% end %&gt;
&lt;% end %&gt;</code></pre> <p>As you can see, this recipe install and configure haproxy. It using <code>search</code> command to get all nodes with role <code>web</code> (by default attributes) and chef environment. After this it collect from all selected nodes hostname and ip address. This data is used to create config for haproxy. This is very useful way, because if you will add or remove node with role <code>web</code> from Chef server, it will automatically update haproxy config. But because we using <code>search</code> command, we need test our cookbook with Chef Zero. Here how it look our tests:</p> <pre><code>require &#39;spec_helper&#39;

describe &#39;my_cool_app::haproxy&#39; do
  let(:platform) { &#39;ubuntu&#39; }
  let(:platform_version) { &#39;12.04&#39; }
  let(:chef_run) { ChefSpec::Runner.new(platform: platform, version: platform_version).converge(described_recipe) }

  it &quot;install haproxy package&quot; do
    expect(chef_run).to install_package(&#39;haproxy&#39;)
  end

  it &#39;enable haproxy service&#39; do
    expect(chef_run).to enable_service(&#39;haproxy&#39;)
  end

  it &#39;create config /etc/haproxy/haproxy.cfg with empty backends&#39; do
    expect(chef_run).to render_file(&#39;/etc/haproxy/haproxy.cfg&#39;).with_content(/#{Regexp.quote(&quot;backend bk_http\nbackend bk_https\n&quot;)}/)
  end

  context &#39;with env, role and one node&#39; do
    let(:node_env) { &#39;test&#39; }
    let(:chef_run) do
      ChefSpec::Runner.new(platform: platform, version: platform_version) do |node|
        # Create a new environment (you could also use a different :let block or :before block)
        env = Chef::Environment.new
        env.name node_env

        # Stub the node to return this environment
        node.stub(:chef_environment).and_return(env.name)

        # Stub any calls to Environment.load to return this environment
        Chef::Environment.stub(:load).and_return(env)
      end.converge(described_recipe)
    end

    before do
      ChefSpec::Server.create_environment(node_env, { description: &#39;Test env&#39; })
      ChefSpec::Server.create_role(&#39;web&#39;, { default_attributes: {} })
      ChefSpec::Server.create_node(&#39;first-node&#39;, {
        run_list: [&#39;role[web]&#39;],
        chef_environment: node_env,
        normal: { fqdn: &#39;127.0.0.1&#39;, hostname: &#39;test.org&#39;, ipaddress: &#39;127.0.0.1&#39; }
      })
    end

    it &#39;create config /etc/haproxy/haproxy.cfg with first-node on 80 port&#39; do
      expect(chef_run).to render_file(&#39;/etc/haproxy/haproxy.cfg&#39;).with_content(/#{Regexp.quote(&#39;server test.org 127.0.0.1:80 weight 1 maxconn 1024 check&#39;)}/)
    end

    it &#39;create config /etc/haproxy/haproxy.cfg with first-node on 443 port&#39; do
      expect(chef_run).to render_file(&#39;/etc/haproxy/haproxy.cfg&#39;).with_content(/#{Regexp.quote(&#39;server test.org 127.0.0.1:443 weight 1 maxconn 1024 check&#39;)}/)
    end

    context &#39;with two nodes&#39; do
      before do
        ChefSpec::Server.create_node(&#39;second-node&#39;, {
          run_list: [&#39;role[web]&#39;],
          chef_environment: node_env,
          normal: { fqdn: &#39;192.168.1.2&#39;, hostname: &#39;test2.org&#39;, ipaddress: &#39;192.168.1.2&#39; }
        })
      end

      it &#39;create config /etc/haproxy/haproxy.cfg with first-node on 80 port&#39; do
        expect(chef_run).to render_file(&#39;/etc/haproxy/haproxy.cfg&#39;).with_content(/#{Regexp.quote(&#39;server test.org 127.0.0.1:80 weight 1 maxconn 1024 check&#39;)}/)
      end

      it &#39;create config /etc/haproxy/haproxy.cfg with first-node on 443 port&#39; do
        expect(chef_run).to render_file(&#39;/etc/haproxy/haproxy.cfg&#39;).with_content(/#{Regexp.quote(&#39;server test.org 127.0.0.1:443 weight 1 maxconn 1024 check&#39;)}/)
      end

      it &#39;create config /etc/haproxy/haproxy.cfg with second-node on 80 port&#39; do
        expect(chef_run).to render_file(&#39;/etc/haproxy/haproxy.cfg&#39;).with_content(/#{Regexp.quote(&#39;server test2.org 192.168.1.2:80 weight 1 maxconn 1024 check&#39;)}/)
      end

      it &#39;create config /etc/haproxy/haproxy.cfg with second-node on 443 port&#39; do
        expect(chef_run).to render_file(&#39;/etc/haproxy/haproxy.cfg&#39;).with_content(/#{Regexp.quote(&#39;server test2.org 192.168.1.2:443 weight 1 maxconn 1024 check&#39;)}/)
      end

    end
  end

end</code></pre> <p>And we can check our tests:</p> <pre><code>$ rspec spec/unit/recipes/haproxy_spec.rb
.........

Finished in 33.34 seconds
9 examples, 0 failures</code></pre> <p>As a result, haproxy recipe fully covered by Chefspec and Chef Zero.</p> <h3 id=using-with-test-kitchen>Using with Test Kitchen</h3> <p>To use Chef Zero with test kitchen, you should change <code>provisioner</code> type in <code>.kitchen.yml</code>:</p> <pre><code>---
driver:
  name: vagrant

provisioner:
  name: chef_zero
  roles_path: &quot;test/chef-zero/roles&quot;
  environments_path: &quot;test/chef-zero/environments&quot;
  nodes_path: &quot;test/chef-zero/nodes&quot;
  client_rb:
    environment: test

platforms:
  - name: ubuntu-12.04
  - name: ubuntu-10.04
  - name: centos-6.4

suites:
  - name: default
    run_list:
      - recipe[my_cool_app::default]
    attributes:
  - name: node
    run_list:
      - recipe[my_cool_app::default]
      - recipe[my_cool_app::node]
    attributes:
  - name: haproxy
    run_list:
      - recipe[my_cool_app::haproxy]
    attributes:
    excludes:
      - centos-6.4</code></pre> <p>As you can see, we changed <code>provisioner name</code> to <code>chef_zero</code>. Also we set <code>roles_path</code>, <code>environments_path</code> and <code>nodes_path</code>. This folders will used to upload to Chef Zero test data - roles, environments and nodes. And we set <code>client_rb</code> attribute, which allow add attributes for chef client. Here we set environment as «test».</p> <p>Next we create new test suite, called «haproxy». Let’s check it:</p> <pre><code>$ kitchen list
Instance             Driver   Provisioner  Last Action
default-ubuntu-1204  Vagrant  ChefZero     &lt;Not Created&gt;
default-ubuntu-1004  Vagrant  ChefZero     &lt;Not Created&gt;
default-centos-64    Vagrant  ChefZero     &lt;Not Created&gt;
node-ubuntu-1204     Vagrant  ChefZero     &lt;Not Created&gt;
node-ubuntu-1004     Vagrant  ChefZero     &lt;Not Created&gt;
node-centos-64       Vagrant  ChefZero     &lt;Not Created&gt;
haproxy-ubuntu-1204  Vagrant  ChefZero     &lt;Not Created&gt;
haproxy-ubuntu-1004  Vagrant  ChefZero     &lt;Not Created&gt;</code></pre> <p>Now lets create folder «integration/haproxy/serverspec» and add to it tests for haproxy recipe:</p> <pre><code>require &#39;serverspec&#39;

include Serverspec::Helper::Exec
include Serverspec::Helper::DetectOS

RSpec.configure do |c|
  c.before :all do
    c.path = &#39;/sbin:/usr/sbin&#39;
  end
end

describe &quot;Haproxy Daemon&quot; do

  describe package(&#39;haproxy&#39;) do
    it { should be_installed }
  end

  describe service(&#39;haproxy&#39;) do
    it { should be_enabled   }
    it { should be_running   }
  end

  [80, 443].each do |port|
    it &quot;is listening on port #{port}&quot; do
      expect(port(port)).to be_listening
    end
  end

  describe file(&#39;/etc/haproxy/haproxy.cfg&#39;) do
    it { should be_file }
    its(:content) { should match /#{Regexp.quote(&#39;server leopard.in.ua 127.0.0.1:80 weight 1 maxconn 1024 check&#39;)}/ }
    its(:content) { should match /#{Regexp.quote(&#39;server leopard.in.ua 127.0.0.1:443 weight 1 maxconn 1024 check&#39;)}/ }
  end

end</code></pre> <p>Almost ready. As you can see, we should generate by tests haproxy config with one node (hostname «leopard.in.ua» and ip address «127.0.0.1»). We should prepare this node for tests. In folder «test/chef-zero/nodes» we create node:</p> <pre><code>{
  &quot;name&quot;: &quot;first-node&quot;,
  &quot;json_class&quot;: &quot;Chef::Node&quot;,
  &quot;chef_type&quot;: &quot;node&quot;,
  &quot;chef_environment&quot;: &quot;test&quot;,
  &quot;normal&quot;: {
    &quot;fqdn&quot;: &quot;127.0.0.1&quot;,
    &quot;hostname&quot;: &quot;leopard.in.ua&quot;,
    &quot;ipaddress&quot;: &quot;127.0.0.1&quot;
  },
  &quot;run_list&quot;: [&quot;role[web]&quot;]
}</code></pre> <p>It should have «test» environment and use «web» role, because only by this conditions we will select this node for haproxy config. Also we set «hostname» and «ipaddress», because this is not real node and Ohai will not fill this attributes. After this we should create «test» environment and «web» role:</p> <pre><code>{
  &quot;name&quot;: &quot;test&quot;,
  &quot;description&quot;: &quot;test environment&quot;,
  &quot;chef_type&quot;: &quot;environment&quot;,
  &quot;json_class&quot;: &quot;Chef::Environment&quot;,
  &quot;default_attributes&quot;: {}
}</code></pre> <pre><code>{
  &quot;name&quot;: &quot;web&quot;,
  &quot;description&quot;: &quot;The web role&quot;,
  &quot;chef_type&quot;: &quot;role&quot;,
  &quot;json_class&quot;: &quot;Chef::Role&quot;,
  &quot;default_attributes&quot;: {
  },
  &quot;run_list&quot;: []
}</code></pre> <p>All this data will load automatically into Chef Zero by Test Kitchen. And now we cat test our haproxy recipe by Test Kitchen:</p> <pre><code>$ kitchen test haproxy-ubuntu-1204
-----&gt; Starting Kitchen (v1.2.1)
-----&gt; Cleaning up any prior instances of &lt;haproxy-ubuntu-1204&gt;
-----&gt; Destroying &lt;haproxy-ubuntu-1204&gt;...
...
Uploading /tmp/busser/suites/serverspec/haproxy_spec.rb (mode=0644)
-----&gt; Running serverspec test suite
/opt/chef/embedded/bin/ruby -I/tmp/busser/suites/serverspec -S /opt/chef/embedded/bin/rspec /tmp/busser/suites/serverspec/haproxy_spec.rb --color --format documentation

       Haproxy Daemon
  is listening on port 80
  is listening on port 443
  Package &quot;haproxy&quot;
    should be installed
  Service &quot;haproxy&quot;
    should be enabled
    should be running
  File &quot;/etc/haproxy/haproxy.cfg&quot;
    should be file
    content
      should match /server\ leopard\.in\.ua\ 127\.0\.0\.1:80\ weight\ 1\ maxconn\ 1024\ check/
    content
      should match /server\ leopard\.in\.ua\ 127\.0\.0\.1:443\ weight\ 1\ maxconn\ 1024\ check/

Finished in 0.55591 seconds
8 examples, 0 failures
       Finished verifying &lt;haproxy-ubuntu-1204&gt; (0m2.20s).
...
       Finished testing &lt;haproxy-ubuntu-1204&gt; (3m26.69s).
-----&gt; Kitchen is finished. (3m28.05s)</code></pre> <p>As a result, haproxy recipe fully covered by Test Kitchen, Serverspec and Chef Zero.</p> <h2 id="sec:testing-minitest">Minitest</h2> <p><a href="https://github.com/seattlerb/minitest">Minitest</a> provides a complete suite of testing facilities supporting <a href="//en.wikipedia.org/wiki/Test-driven_development">TDD</a>, <a href="//en.wikipedia.org/wiki/Behavior-driven_development">BDD</a>, mocking, and benchmarking. Minitest doesn’t reinvent anything that ruby already provides, like: classes, modules, inheritance, methods. This means you only have to learn ruby to use minitest and all of your regular OO practices like extract-method refactorings still apply.</p> <p>Exists two way of usage minitest:</p> <ul> <li><p>With Test Kitchen (like bats or serverspec)</p></li> <li><p>Testing node after cooking by minitest-chef-handler</p></li> </ul> <p>Second way is very interesting, because allow to you check tests even on production environment. This allow to be sure, what tests pass on check run of chef client on node.</p> <p>Let’s consider each example.</p> <h3 id=test-kitchen>Test Kitchen</h3> <p>As you remember, we used bats and serverspec with Test Kitchen. But inside it you can use any test framework, for which exists «busser». Right now you can find:</p> <ul> <li><p>busser-minitest</p></li> <li><p>busser-bats</p></li> <li><p>busser-bash</p></li> <li><p>busser-serverspec</p></li> <li><p>busser-rspec</p></li> <li><p>busser-cucumber</p></li> </ul> <p>Let’s add little test inside our cookbook:</p> <pre><code>require &#39;minitest/autorun&#39;

describe &quot;my_cool_app::default&quot; do

  it &quot;has created /var/www/my_cool_app/index.html&quot; do
    assert File.exists?(&quot;/var/www/my_cool_app/index.html&quot;)
  end

end</code></pre> <p>And check how it works:</p> <pre><code>$ kitchen test default-ubuntu-1204
-----&gt; Starting Kitchen (v1.2.1)
-----&gt; Cleaning up any prior instances of &lt;default-ubuntu-1204&gt;
-----&gt; Destroying &lt;default-ubuntu-1204&gt;...
...
       Plugin minitest installed (version 0.2.0)
-----&gt; Running postinstall for minitest plugin
...
-----&gt; Running minitest test suite
/opt/chef/embedded/bin/ruby  -I&quot;/opt/chef/embedded/lib/ruby/1.9.1&quot; &quot;/opt/chef/embedded/lib/ruby/1.9.1/rake/rake_test_loader.rb&quot; &quot;/tmp/busser/suites/minitest/test_default.rb&quot;
Run options: --seed 59554

# Running tests:

.

Finished tests in 0.002407s, 415.5347 tests/s, 415.5347 assertions/s.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
       Finished verifying &lt;default-ubuntu-1204&gt; (0m2.39s).
-----&gt; Kitchen is finished. (1m27.97s)</code></pre> <p>As you can see, minitest doesn’t have additional helpers, like have serverspec (<code>be_listening</code>, <code>be_running</code>, etc). What is why let’s consider second way of using it.</p> <h3 id=minitest-chef-handler>Minitest Chef Handler</h3> <p>Minitest-chef-handler run minitest suites after your Chef recipes to check the status of your system. It can be very useful, because you testing inside your real environment. Exists 2 option to use it:</p> <p>Option 1: Add the report handler to your client.rb or solo.rb file:</p> <pre><code>require &#39;minitest-chef-handler&#39;

report_handlers « MiniTest::Chef::Handler.new</code></pre> <p>Option 2: Using <a href="https://github.com/btm/minitest-handler-cookbook">minitest-handler</a> cookbook, which should be added in the end of <code>run_list</code>:</p> <pre><code>chef.run_list = [
  &quot;your-recipes&quot;,
  &quot;minitest-handler&quot;
]</code></pre> <p>I prefer second variant. Just add in <code>Berksfile</code> cookbook <code>minitest-handler</code>:</p> <pre><code>source &quot;http://api.berkshelf.com&quot;

metadata

cookbook &quot;minitest-handler&quot;</code></pre> <p>Add it in <code>run_list</code>:</p> <pre><code>suites:
  - name: default
    run_list:
      - recipe[my_cool_app::default]
      - recipe[minitest-handler]</code></pre> <p>Next we should write some tests. Let’s create folder to its:</p> <pre><code>$ mkdir -p files/default/test</code></pre> <p>And add some tests to cover default recipe:</p> <pre><code>require &#39;minitest/spec&#39;

describe_recipe &#39;my_cool_app::default&#39; do

  it &quot;install ntp package&quot; do
    package(&#39;ntp&#39;).must_be_installed
  end

  it &quot;install git package&quot; do
    if &quot;ubuntu&quot; == node[&#39;platform&#39;] &amp;&amp; node[&#39;platform_version&#39;].to_f &lt;= 10.04
      pack = &quot;git-core&quot;
    else
      pack = &quot;git&quot;
    end
    package(pack).must_be_installed
  end

  it &quot;nginx must running&quot; do
    service(&quot;nginx&quot;).must_be_running
  end

end</code></pre> <p>Finally run our chef-client by Test Kitchen «converge» command:</p> <pre><code>$ kitchen converge default-ubuntu-1204
...
Running handlers:
[2014-03-27T20:30:03+00:00] INFO: Running report handlers
Run options: -v --seed 42106

# Running tests:

recipe::my_cool_app::default#test_0002_install git package = 0.14 s = .
recipe::my_cool_app::default#test_0001_install ntp package = 0.08 s = .
recipe::my_cool_app::default#test_0003_nginx must running = 0.09 s = .</code></pre> <p>As a result, after launching all recipes in <code>run_list</code>, last recipe <code>minitest-handler::default</code> run minitest to check status of the node.</p> <h2 id="sec:testing-cucumber-spec">Cucumber</h2> <p><a href="//cukes.info/">Cucumber</a> is a tool for running automated tests written in plain language. Because they’re written in plain language, they can be read by anyone on your team. Because they can be read by anyone, you can use them to help improve communication, collaboration and trust on your team.</p> <h3 id=example-4>Example</h3> <p>Therefore we need only add the following three gems to a Gemfile:</p> <pre><code>gem &#39;cucumber&#39;
gem &#39;rspec-expectations&#39;
gem &#39;leibniz&#39;</code></pre> <p>And you should to execute <code>bundle</code> command to install this gem.</p> <p>Next we should create directory for our tests:</p> <pre><code>$ mkdir -p features/step_definitions
$ mkdir -p features/step_definitions/support</code></pre> <p>And require needed libs in <code>features/step_definitions/support/env.rb</code> file:</p> <pre><code>require &#39;leibniz&#39;
require &#39;faraday&#39;</code></pre> <p>Now we should create file, which will contain tests definitions. Let’s call it <code>features/working_web_page.feature</code>:</p> <pre><code>Feature: Customer can use my cool web app

  In order to get more payment customers
  As a business owner
  I want web users to be able use my cool web app

  Background:
    Given I have provisioned the following infrastructure:
    | Server Name | Operating System | Version | Chef Version | Run List              |
    | localhost   | ubuntu           | 12.04   | 11.4.4       | my_cool_app::default  |

    And I have run Chef

  Scenario: User visits home page
    Given a url &quot;http://example.org&quot;
    When a web user browses to the URL
    Then the user should see &quot;This is my cool web app&quot;
    And cleanup test env</code></pre> <p>Next, we can try run cucumber:</p> <pre><code>$ cucumber
Feature: Customer can use my cool web app

  In order to get more payment customers
  As a business owner
  I want web users to be able use my cool web app

  Background:                                              # features/working_web_page.feature:7
    Given I have provisioned the following infrastructure: # features/working_web_page.feature:8
      | Server Name | Operating System | Version | Chef Version | Run List             |
      | localhost   | ubuntu           | 12.04   | 11.4.4       | my_cool_app::default |
    And I have run Chef                                    # features/working_web_page.feature:12

  Scenario: User visits home page                          # features/working_web_page.feature:14
    Given a url http://example.org                         # features/working_web_page.feature:15
    When a web user browses to the URL                     # features/working_web_page.feature:16
    Then the user should see &quot;This is my cool web app&quot;     # features/working_web_page.feature:17

1 scenario (1 undefined)
5 steps (5 undefined)
0m0.012s

You can implement step definitions for undefined steps with these snippets:

Given(/^I have provisioned the following infrastructure:$/) do |table|
  # table is a Cucumber::Ast::Table
  pending # express the regexp above with the code you wish you had
end

Given(/^I have run Chef$/) do
  pending # express the regexp above with the code you wish you had
end

Given(/^a url http:\/\/example\.org$/) do
  pending # express the regexp above with the code you wish you had
end

When(/^a web user browses to the URL$/) do
  pending # express the regexp above with the code you wish you had
end

Then(/^the user should see &quot;(.*?)&quot;$/) do |arg1|
  pending # express the regexp above with the code you wish you had
end

If you want snippets in a different programming language,
just make sure a file with the appropriate file extension
exists where cucumber looks for step definitions.</code></pre> <p>As you can see, we dont have any line of real tests. Let’s add tests in file <code>features/step_definitions/working_web_page.rb</code>:</p> <pre><code>Given(/^I have provisioned the following infrastructure:$/) do |specification|
  @infrastructure = Leibniz.build(specification)
end

Given(/^I have run Chef$/) do
  @infrastructure.destroy
  @infrastructure.converge
end

Given(/^a url &quot;(.*?)&quot;$/) do |url|
  @host_header = url.split(&#39;/&#39;).last
end

When(/^a web user browses to the URL$/) do
  connection = Faraday.new(:url =&gt; &quot;http://#{@infrastructure[&#39;localhost&#39;].ip}&quot;, :headers =&gt; {&#39;Host&#39; =&gt; @host_header}) do |faraday|
    faraday.adapter Faraday.default_adapter
  end
  @page = connection.get(&#39;/&#39;).body
end

Then(/^the user should see &quot;(.*?)&quot;$/) do |content|
  expect(@page).to match /#{content}/
end

Then(/^cleanup test env$/) do
  @infrastructure.destroy if @infrastructure
end</code></pre> <p>Leibniz gem read infrastructure configuration from our specs inside «Background» and use Test Kitchen to create it. Next, in «I have run Chef» we cleanup old and create new node, install chef client and run it inside node. After this we using Faraday gem to do HTTP request inside node and get root page content. We are checking, what this content should contain «This is my cool web app». In this case we will be sure, what nginx installed, running and serve our web page. In the end we added «cleanup test env», which would remove node after tests.</p> <p>Finally, we cat test our cucumber tests:</p> <pre><code>$ cucumber
Feature: Customer can use my cool web app

  In order to get more payment customers
  As a business owner
  I want web users to be able use my cool web app

  Background:                                              # features/working_web_page.feature:7
    Given I have provisioned the following infrastructure: # features/step_definitions/working_web_page.rb:1
      | Server Name | Operating System | Version | Chef Version | Run List             |
      | localhost   | ubuntu           | 12.04   | 11.4.4       | my_cool_app::default |
-----&gt; Destroying &lt;leibniz-localhost&gt;...
       ==&gt; default: Forcing shutdown of VM...
       ==&gt; default: Destroying VM and associated drives...
...

Chef Client finished, 28 resources updated
       Finished converging &lt;leibniz-localhost&gt; (1m6.98s).
    And I have run Chef                                    # features/step_definitions/working_web_page.rb:5

  Scenario: User visits home page                          # features/working_web_page.feature:14
    Given a url &quot;http://example.org&quot;                       # features/step_definitions/working_web_page.rb:10
    When a web user browses to the URL                     # features/step_definitions/working_web_page.rb:14
    Then the user should see &quot;This is my cool web app&quot;     # features/step_definitions/working_web_page.rb:21
-----&gt; Destroying &lt;leibniz-localhost&gt;...
       ==&gt; default: Forcing shutdown of VM...
       ==&gt; default: Destroying VM and associated drives...
       Vagrant instance &lt;leibniz-localhost&gt; destroyed.
       Finished destroying &lt;leibniz-localhost&gt; (0m7.15s).
    And cleanup test env                                   # features/step_definitions/working_web_page.rb:25

1 scenario (1 passed)
6 steps (6 passed)
2m41.004s</code></pre> <p>As a result, we cover our default recipe by using cucumber.</p> <h2 id="sec:testing-analysis-and-linting">Static Analysis and Linting Tools</h2> <h3 id=foodcritic>Foodcritic</h3> <p><a href="//www.foodcritic.io/">Foodcritic</a> is a lint tool for your Opscode Chef cookbooks. Foodcritic has two goals:</p> <ul> <li><p>To make it easier to flag problems in your Chef cookbooks that will cause Chef to blow up when you attempt to converge. This is about faster feedback. If you automate checks for common problems you can save a lot of time.</p></li> <li><p>To encourage discussion within the Chef community on the more subjective stuff - what does a good cookbook look like? Opscode have avoided being overly prescriptive which by and large I think is a good thing. Having a set of rules to base discussion on helps drive out what we as a community think is good style.</p></li> </ul> <p>On main site you can find <a href="//www.foodcritic.io/">list of rules</a>. Also you can define own list of rules (if you need this). Foodcritic is like jslint for cookbooks. At the bare minimum, you should run foodcritic against all your cookbooks.</p> <h4 id=example-5>Example</h4> <p>We need to add foodcritic gems in Gemfile inside our <code>my_cool_app</code> cookbook:</p> <pre><code>source &#39;https://rubygems.org&#39;

gem &#39;berkshelf&#39;
gem &#39;foodcritic&#39;</code></pre> <p>And you should to execute <code>bundle</code> command to install this gem. Next we can to check <code>my_cool_app</code> cookbook by foodcritic:</p> <pre><code>$ foodcritic .
FC015: Consider converting definition to a LWRP: ./definitions/enable_web_site.rb:1
FC021: Resource condition in provider may not behave as expected: ./providers/know_host.rb:39
FC048: Prefer Mixlib::ShellOut: ./libraries/provider_known_host.rb:56
FC048: Prefer Mixlib::ShellOut: ./providers/know_host.rb:33</code></pre> <p>We have a few warnings in the code. Let’s fix them:</p> <pre><code>my_cool_app/libraries/provider_known_host.rb
@@ -53,7 +53,8 @@ class Chef
       private

       def insure_for_file(new_resource)
-        key = (new_resource.key || `ssh-keyscan -H -p #{new_resource.port} #{new_resource.host} 2&gt;&amp;1`)
+        cmd = Mixlib::ShellOut.new(&quot;ssh-keyscan -H -p #{new_resource.port} #{new_resource.host} 2&gt;&amp;1&quot;)
+        key = (new_resource.key || cmd.run_command.stdout)
         comment = key.split(&quot;\n&quot;).first || &quot;&quot;

my_cool_app/providers/know_host.rb
@@ -30,13 +30,15 @@ action :delete do
 end

 def insure_for_file(new_resource)
-  key = (new_resource.key || `ssh-keyscan -H -p #{new_resource.port} #{new_resource.host} 2&gt;&amp;1`)
+  cmd = Mixlib::ShellOut.new(&quot;ssh-keyscan -H -p #{new_resource.port} #{new_resource.host} 2&gt;&amp;1&quot;)
+  key = (new_resource.key || cmd.run_command.stdout)
   comment = key.split(&quot;\n&quot;).first || &quot;&quot;

   Chef::Application.fatal! &quot;Could not resolve #{new_resource.host}&quot; if key =~ /getaddrinfo/

   # Ensure that the file exists and has minimal content (required by Chef::Util::FileEdit)
-  file new_resource.known_hosts_file do
+  file &quot;Check what file #{new_resource.known_hosts_file} exists for #{new_resource.name}&quot; do
+    path          new_resource.known_hosts_file
     action        :create
     backup        false
     content       &#39;# This file must contain at least one line. This is that line.&#39;</code></pre> <p>And run again <code>foodcritic</code>:</p> <pre><code>$  foodcritic .
FC015: Consider converting definition to a LWRP: ./definitions/enable_web_site.rb:1</code></pre> <p>As you can see almost all warnings fixed.</p> <h4 id=integration-by-rake>Integration by Rake</h4> <p>Foodcritic has unreleased experimental support for Rake included. With foodcritic and rake in your Gemfile your Rakefile would look like this:</p> <pre><code>require &#39;foodcritic&#39;
task :default =&gt; [:foodcritic]
FoodCritic::Rake::LintTask.new</code></pre> <p>You can also pass a block when instantiating to configure the lint options:</p> <pre><code>require &#39;foodcritic&#39;
task :default =&gt; [:foodcritic]
FoodCritic::Rake::LintTask.new do |t|
  t.options = {:fail_tags =&gt; [&#39;correctness&#39;]}
end</code></pre> <h4 id=integration-by-thor>Integration by Thor</h4> <p>While Rake is the old grand-daddy of Ruby build tools, a number of people prefer to use Thor.</p> <p>We need to add <a href="https://github.com/reset/thor-foodcritic">thor-foodcritic</a> gem in Gemfile inside our <code>my_cool_app</code> cookbook:</p> <pre><code>source &#39;https://rubygems.org&#39;

gem &#39;berkshelf&#39;
gem &#39;foodcritic&#39;
gem &#39;thor-foodcritic&#39;</code></pre> <p>And you should to execute <code>bundle</code> command to install this gem. Add the FoodCritic tasks to Thorfile:</p> <pre><code># encoding: utf-8

require &#39;bundler&#39;
require &#39;bundler/setup&#39;
require &#39;berkshelf/thor&#39;
require &#39;thor/foodcritic&#39;</code></pre> <p>And then get a list of your thor tasks:</p> <pre><code>$ thor list
...
foodcritic
----------
thor foodcritic:lint  # Run a lint test against the specified Cookbook and Role paths or otherwise your current working directory.

...</code></pre> <p>Run the lint task to get a review:</p> <pre><code>$ thor foodcritic:lint
FC015: Consider converting definition to a LWRP: /Users/leo/Documents/chef_book/code/my-server-cloud/site-cookbooks/my_cool_app/definitions/enable_web_site.rb:1</code></pre> <p>Get info about options:</p> <pre><code>$ thor help foodcritic:lint
Usage:
  thor foodcritic:lint

Options:
  -B, [--cookbook-path=one two three]  # Cookbook path(s) to check.
                                       # Default: /Users/leo/Documents/chef_book/code/my-server-cloud/site-cookbooks/my_cool_app
  -R, [--role-path=one two three]      # Role path(s) to check.
  -t, [--tags=one two three]           # Only check against rules with the specified tags.
  -I, [--include=one two three]        # Additional rule file path(s) to load.
  -f, [--epic-fail=one two three]      # Fail the build if any of the specified tags are matched.
  -e, [--exclude-paths=one two three]  # Paths to exclude when running tests.
                                       # Default: [&quot;test/**/*&quot;, &quot;spec/**/*&quot;, &quot;features/**/*&quot;]

Run a lint test against the specified Cookbook and Role paths or otherwise your current working directory.</code></pre> <p>We can ignore some rules by using tags. For example, to ignore <code>FC015</code> warning, we can run command:</p> <pre><code>$ thor foodcritic:lint -t ~FC015

$</code></pre> <p>Or we can use <code>.foodcritic</code> file inside our cookbook folder and add tags inside it:</p> <pre><code>$ cat .foodcritic
~FC015

$ thor foodcritic:lint

$</code></pre> <p>Here we use the tilde <code>~</code> to exclude <code>FC015</code>. For example, if we need check only rules, which have tags <code>services</code> and <code>style</code>, we use directly by foodcritic command:</p> <pre><code>$ foodcritic -t style,services .

$</code></pre> <p>Or with Thor:</p> <pre><code>$ thor foodcritic:lint -t style,services

$</code></pre> <p>As you can see, in this case you can add this command in your Continuous integration (CI) and check your cookbook by foodcritic.</p> <h4 id=extra-rules>Extra Rules</h4> <p>Except standart rules exists additional rules that you can use with foodcritic:</p> <ul> <li><p><a href="https://github.com/customink-webops/foodcritic-rules">CustomInk Foodcritic Rules</a></p></li> <li><p><a href="https://github.com/etsy/foodcritic-rules">Etsy Foodcritic Rules</a></p></li> <li><p><a href="https://github.com/lookout/lookout-foodcritic-rules">Lookout Foodcritic Rules</a></p></li> </ul> <p>And, of course, you can write own number of rules for your cookbooks.</p> <h3 id=rubocop>RuboCop</h3> <p><a href="https://github.com/bbatsov/rubocop">RuboCop</a> is a Ruby static code analyzer. Out of the box it will enforce many of the guidelines outlined in the community <a href="https://github.com/bbatsov/ruby-style-guide">Ruby Style Guide</a>.</p> <h4 id=example-6>Example</h4> <p>First we should add this gem in Gemfile:</p> <pre><code>source &#39;https://rubygems.org&#39;

gem &#39;rubocop&#39;, require: false</code></pre> <p>And you should to execute <code>bundle</code> command to install this gems.</p> <p>After this you can use command line tool «rubocop» to check your Ruby code by community style guide:</p> <pre><code>$ rubocop
Inspecting 24 files
CCCCWCCCCCCCCCCCCCCCWWCC

Offenses:

attributes/default.rb:4:55: C: Source files should end with a newline (\n).
default[&#39;my_cool_app&#39;][&#39;web_host&#39;]      = &#39;example.org&#39;
                                                      ^

...

test/integration/node/serverspec/nginx_daemon_spec.rb:18:6: C: Prefer single-quoted strings when you don&#39;t need string interpolation or special symbols.
  it &quot;has a running service of nginx&quot; do
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
test/integration/node/serverspec/nginx_daemon_spec.rb:19:20: C: Prefer single-quoted strings when you don&#39;t need string interpolation or special symbols.
    expect(service(&quot;nginx&quot;)).to be_running
                   ^^^^^^^
test/integration/node/serverspec/nginx_daemon_spec.rb:22:3: C: Source files should end with a newline (\n).
end
  ^
test/integration/node/serverspec/node_spec.rb:12:10: C: Prefer single-quoted strings when you don&#39;t need string interpolation or special symbols.
describe &quot;Node&quot; do
         ^^^^^^
test/integration/node/serverspec/node_spec.rb:18:3: C: Source files should end with a newline (\n).
end
  ^
24 files inspected, 229 offenses detected</code></pre> <p>As you can see, this code contain many problems in Ruby style, which can be fixed.</p> <p>The behavior of RuboCop can be controlled via the <code>.rubocop.yml</code> configuration file. It makes it possible to enable/disable certain cops (checks) and to alter their behavior if they accept any parameters. The file can be placed either in your home directory or in some project directory.</p> <h3 id=strainer>Strainer</h3> <p><a href="https://github.com/customink/strainer">Strainer</a> is a gem for isolating and testing individual chef cookbooks. It allows you to keep all your cookbooks in a single repository (saving you time and money), while having all the benefits of individual repositories. But also you can use Strainer in «standalone» mode. This allows you to use Strainer file from within a cookbook.</p> <h4 id=example-7>Example</h4> <p>First, add it in Gemfile:</p> <pre><code>source &#39;https://rubygems.org&#39;

gem &#39;berkshelf&#39;
gem &#39;foodcritic&#39;
gem &#39;thor-foodcritic&#39;
gem &#39;chefspec&#39;
gem &#39;test-kitchen&#39;
gem &#39;chef-zero&#39;

group :integration do
  gem &#39;kitchen-vagrant&#39;
  gem &#39;cucumber&#39;
  gem &#39;rspec-expectations&#39;
  gem &#39;leibniz&#39;, &#39;~&gt; 0.2.1&#39;
end

gem &#39;rubocop&#39;, require: false
gem &#39;strainer&#39;, require: false</code></pre> <p>And run «bundle» command to install it.</p> <p>Next you must create file Strainerfile with such content:</p> <pre><code>chefspec:   bundle exec rspec --color
kitchen:    bundle exec thor kitchen:default-ubuntu-1204</code></pre> <p>Strainer have similar functionality as <a href="//ddollar.github.io/foreman/">Foreman</a>, but for running tests inside cookbook(s). Now we cat test our cookbook:</p> <pre><code>$ bundle exec strainer test
# Straining &#39;my_cool_app (v0.1.0)&#39;
chefspec             | bundle exec rspec --color
chefspec             | ..................
chefspec             | Finished in 1 minute 22.43 seconds
chefspec             | 23 examples, 0 failures
chefspec             | SUCCESS!
kitchen              | bundle exec thor kitchen:default-ubuntu-1204
kitchen              | -----&gt; Cleaning up any prior instances of &lt;default-ubuntu-1204&gt;
kitchen              | -----&gt; Destroying &lt;default-ubuntu-1204&gt;...

...

kitchen              |        Vagrant instance &lt;default-ubuntu-1204&gt; destroyed.
kitchen              |        Finished destroying &lt;default-ubuntu-1204&gt; (0m6.87s).
kitchen              |
kitchen              | SUCCESS!
Strainer marked build OK</code></pre> <p>Also you can use it with Rake or Thor command line tools.</p> <h2 id=summary-4>Summary</h2> <p>Chef cookbook testing is very important part of cookbook development. Testing process allow for developers and devops to be sure, what important parts of cookbook working as expected and new updated and features will not break cookbook workflow.</p> <h1 id=tips-and-tricks>Tips and Tricks</h1> <h2 id="sec:tat-wrapper-cookbook">Wrapper cookbook</h2> <p>A wrapper cookbook wraps an upstream cookbook to change its behavior without forking it.</p> <p>There are two main reasons you might want to do this:</p> <ul> <li><p>Codifying the standard settings for your organization or business unit’s use of that cookbook without placing those attributes in a role</p></li> <li><p>Modifying the behavior of an upstream cookbook</p></li> </ul> <h3 id=codifying-standards-in-your-organization>Codifying Standards in Your Organization</h3> <p>Suppose I use the community <a href="https://supermarket.getchef.com/cookbooks/ntp">ntp</a> cookbook but I want to enforce a set of timeservers across my infrastructure. Instead of running this cookbook directly, I could create an <code>acmeco-ntp</code> cookbook with the following settings:</p> <pre><code>default[&#39;ntp&#39;][&#39;peers&#39;] = [&#39;ntp1.acmeco.com&#39;, &#39;ntp2.acmeco.com&#39;]</code></pre> <pre><code>include_recipe &#39;ntp&#39;</code></pre> <p>Now I can simply run <code>recipe[acmeco-ntp]</code> in my infrastructure and the default settings will take effect.</p> <p>Note that it is not necessary to use normal or override priority here. Dependent cookbooks are loaded first by Chef Client and their attribute files are evaluated before those of the caller.</p> <h3 id=modifying-upstream-cookbook-behavior>Modifying Upstream Cookbook Behavior</h3> <p>Sometimes you want to modify the behavior of an upstream cookbook without forking it. For example, let’s take the <a href="https://supermarket.getchef.com/cookbooks/postgresql">PostgreSQL community cookbook</a>. It installs whatever PostgreSQL packages come from your operating system distribution. Suppose you want to install version 9.4 of PostgreSQL on an operating system that would not natively provide it (e.g. RedHat Enterprise Linux 6) but those packages can be found in the official PostgreSQL Global Development Group (PGDG) repository. How would you go about doing that? You could write a wrapper cookbook that set the right attributes:</p> <pre><code>default[&#39;postgresql&#39;][&#39;version&#39;] = &#39;9.4&#39;
default[&#39;postgresql&#39;][&#39;client&#39;][&#39;packages&#39;] = [&quot;postgresql#{node[&#39;postgresql&#39;][&#39;version&#39;].split(&#39;.&#39;).join}-devel&quot;]
default[&#39;postgresql&#39;][&#39;server&#39;][&#39;packages&#39;] = [&quot;postgresql#{node[&#39;postgresql&#39;][&#39;version&#39;].split(&#39;.&#39;).join}-server&quot;]
default[&#39;postgresql&#39;][&#39;contrib&#39;][&#39;packages&#39;] = [&quot;postgresql#{node[&#39;postgresql&#39;][&#39;version&#39;].split(&#39;.&#39;).join}-contrib&quot;]
default[&#39;postgresql&#39;][&#39;dir&#39;] = &quot;/var/lib/pgsql/#{node[&#39;postgresql&#39;][&#39;version&#39;]}/data&quot;
default[&#39;postgresql&#39;][&#39;server&#39;][&#39;service_name&#39;] = &quot;postgresql-#{node[&#39;postgresql&#39;][&#39;version&#39;]}&quot;</code></pre> <pre><code>include_recipe &#39;postgresql::yum_pgdg_postgresql&#39;
include_recipe &#39;postgresql::server&#39;</code></pre> <p>What’s with the repetition of computed attributes in the wrapper? Well, the values for <code>default['postgresql']['client']['packages']</code> and so on were calculated when the attributes were loaded by the dependency, so to recompute them based on the new value, we need to restate the expressions.</p> <p>You could do all of this work in roles as well — and if you do, the computed attributes will be correctly resolved without this kind of repetition. This is another reason that roles are still valuable.</p> <p>You can take this one step further: suppose you wanted to then derive the <code>pg_hba.conf</code> (the database access control file in PostgreSQL) through some external mechanism that isn’t supported in the upstream cookbook. No problem: you can also set an attribute in recipe context, before the <code>include_recipe</code> statements above:</p> <pre><code>pg_hba_hash = call_some_method_to_get_a_hash()
node.default[&#39;postgresql&#39;][&#39;pg_hba&#39;] = pg_hba_hash</code></pre> <p>Again, in recipe context, there is no need to use normal or override priority to achieve the desired effect.</p> <h3 id=advanced-upstream-cookbook-modification>Advanced Upstream Cookbook Modification</h3> <p>You can also use wrapper cookbooks to manipulate Chef’s Resource Collection. Put simply, the resource collection is the ordered list of resources, from the recipes in your expanded run list, that are to be run on a node. You can manipulate attributes of the resources in the resource collection. One common use case for this is to change the template used by an upstream cookbook to the caller’s cookbook. Again, suppose I’m using the PostgreSQL cookbook but I really hate the sysconfig template that it uses. I can simply make my own template inside the wrapper cookbook:</p> <pre><code>PGDATA=&lt;%= node[&#39;postgresql&#39;][&#39;dir&#39;] %&gt;
&lt;% if node[&#39;postgresql&#39;][&#39;config&#39;].attribute?(&quot;port&quot;) -%&gt;
PGPORT=&lt;%= node[&#39;postgresql&#39;][&#39;config&#39;][&#39;port&#39;] %&gt;
&lt;% end -%&gt;
PGCHEFS=&quot;Ohai&quot; # or whatever changes you want to make</code></pre> <p>and «rewind» the resource collection definition after that resource has been loaded by <code>recipe[postgresql::server]</code> to change its cookbook attribute:</p> <pre><code>include_recipe &#39;postgresql::yum_pgdg_postgresql&#39;
include_recipe &quot;postgresql::server&quot;

resources(&quot;template[/etc/sysconfig/pgsql/#{node[&#39;postgresql&#39;][&#39;server&#39;][&#39;service_name&#39;]}]&quot;).cookbook &#39;acmeco-postgresql&#39;</code></pre> <p>You can play this game with any other parameters to a previously defined resource that you want to change. Because Chef uses a two-phase execution model (compile, then converge), you can manipulate the results of that compilation in many different ways before convergence happens.</p> <p><a href="https://github.com/bryanwb/chef-rewind">Chef Rewind gem</a> will also do this kind of manipulation.</p> <h3 id=summary-5>Summary</h3> <p>Wrapper cookbooks allow you to modify the behavior of upstream cookbooks without forking them. These modifications can be very straightforward, such as you might do with a role, except that they can contain logic to govern the changes you want to make. Or the modifications can get quite advanced, through altering the resources in the resource collection.</p> <p>It’s useful to name your wrapper cookbooks with a standard prefix that denotes your organization (e.g. «oc-» is what we use at Opscode). That distinguishes your wrapper from the cookbook you’re wrapping.</p> <p>Finally, you need not strictly adopt only wrapper cookbooks or only roles. Used effectively, both roles and wrapper cookbooks give you a wealth of tools to model your infrastructure effectively.</p> <h2 id="sec:tat-knife-plugins">Knife Plugins</h2> <p>A Knife plugin is a set of one (or more) subcommands that can be added to Knife to support additional functionality that is not built-in to the base set of Knife subcommands. Many of the Knife plugins are built by members of the Chef community and several of them are built and maintained by Chef. A Knife plugin is installed to the <code>~/.chef/plugins/knife/</code> directory, from where it can be run just like any other Knife subcommand.</p> <ul> <li><p>the same common options used by Knife subcommands can also be used by Knife plug-ins;</p></li> <li><p>a Knife plugin can make authenticated API requests to the Chef server;</p></li> </ul> <p>The following Knife plug-ins are maintained by Chef:</p> <ul> <li><p><strong>knife azure</strong> - Microsoft Azure is a cloud hosting platform from Microsoft that provides virtual machines for Linux and Windows Server, cloud and database services, and more. The knife azure subcommand is used to manage API-driven cloud servers that are hosted by Microsoft Azure;</p></li> <li><p><strong>knife bluebox</strong> - Blue Box provides on-demand computing that is backed by a proprietary cloud operating system. The knife bluebox subcommand is used to manage API-driven cloud servers that are hosted by Blue Box;</p></li> <li><p><strong>knife ec2</strong> - Amazon EC2 is a web service that provides resizable compute capacity in the cloud, based on pre-configured operating systems and virtual application software using Amazon Machine Images (AMI). The knife ec2 subcommand is used to manage API-driven cloud servers that are hosted by Amazon EC2;</p></li> <li><p><strong>knife eucalyptus</strong> - Eucalyptus is an infrastructure as a service (IaaS) platform that supports hybrid-IaaS configurations that allow data to move between hosted and on-premise data centers. The knife eucalyptus subcommand is used to manage API-driven cloud servers that are hosted by Eucalyptus;</p></li> <li><p><strong>knife google</strong> - Google Compute Engine is a cloud hosting platform that offers scalable and flexible virtual machine computing. The knife google subcommand is used to manage API-driven cloud servers that are hosted by Google Compute Engine;</p></li> <li><p><strong>knife hp</strong> - HP Cloud Compute is a cloud hosting platform that provides computing, storage, identity, and other services across private, managed, and public clouds. The knife hp subcommand is used to manage API-driven cloud servers that are hosted by HP Cloud Compute;</p></li> <li><p><strong>knife linode</strong> - Linode is a cloud hosting platform that provides virtual private server hosting from the kernal and root access on up. The knife linode subcommand is used to manage API-driven cloud servers that are hosted by Linode;</p></li> <li><p><strong>knife openstack</strong> - The knife openstack subcommand is used to manage API-driven cloud servers that are hosted by OpenStack;</p></li> <li><p><strong>knife rackspace</strong> - Rackspace is a cloud-driven platform of virtualized servers that provide services for storage and data, platform and networking, and cloud computing. The knife rackspace subcommand is used to manage API-driven cloud servers that are hosted by Rackspace cloud services;</p></li> <li><p><strong>knife terremark</strong> - Terremark is a cloud hosting platform that provides cloud, IT infrastructure, and managed hosting services. The knife terremark subcommand is used to manage API-driven cloud servers that are hosted by Terremark;</p></li> <li><p><strong>knife windows</strong> - The knife windows subcommand is used to configure and interact with nodes that exist on server and/or desktop machines that are running Microsoft Windows. Nodes are configured using Windows Remote Management, which allows native objects—batch scripts, Windows PowerShell scripts, or scripting library variables—to be called by external applications;</p></li> </ul> <h3 id=examples>Examples</h3> <p>Let’s consider an example of using <strong>knife ec2</strong> plugin. First of all you should install it. You can use bundler or rubugems:</p> <pre><code>$ gem install knife-ec2</code></pre> <p>The <code>server create</code> argument is used to create a new Amazon EC2 cloud instance. This will provision a new image in Amazon EC2, perform a bootstrap (using the SSH protocol), and then install the chef-client on the target system so that it can be used to configure the node and to communicate with a Chef server.</p> <p>To launch a new Amazon EC2 instance with the «webserver» role (Ubuntu Server 14.04 LTS (HVM), c3.large type):</p> <pre><code>$ knife ec2 server create -r &quot;role[webserver]&quot; -I ami-a6926dce -f c3.large -G www,default -x ubuntu -N server01 -A aws-access-key-id -K aws-secret-access-key -S aws/servers.pem</code></pre> <p>Let’s look at the meaning of these options:</p> <ul> <li><p><code>-A KEY, --aws-access-key-id KEY</code> - the access key identifier used with Amazon EC2;</p></li> <li><p><code>-K SECRET, --aws-secret-access-key SECRET</code> - the secret access key for the API endpoint used with Amazon EC2;</p></li> <li><p><code>-f FLAVOR, --flavor FLAVOR</code> - the name of the flavor that identifies the hardware configuration of the server, including disk space, memory capacity, and CPU priority;</p></li> <li><p><code>-G X,Y,Z, --groups X,Y,Z</code> - a comma-separated list of security groups. Not supported when using Amazon Virtual Private Cloud;</p></li> <li><p><code>-x USERNAME, --ssh-user USERNAME</code> - the SSH user name;</p></li> <li><p><code>-r RUN_LIST, --run-list RUN_LIST</code> - a comma-separated list of roles and/or recipes to be applied;</p></li> <li><p><code>-S KEY, --ssh-key KEY</code> - the SSH key for the Amazon EC2 environment;</p></li> </ul> <p>Some of this keys possible to setup inside <code>knife.rb</code>:</p> <pre><code>$ cat ~/.chef/knife.rb
knife[:availability_zone] = ENV[&#39;EC2_AVAILABILITY_ZONE&#39;]
knife[:aws_access_key_id] = ENV[&#39;AWS_ACCESS_KEY_ID&#39;]
knife[:aws_secret_access_key] = ENV[&#39;AWS_SECRET_ACCESS_KEY&#39;]
knife[:aws_ssh_key_id] = &quot;aws/servers.pem&quot;
knife[:image] = &quot;ami-a6926dce&quot;
knife[:flavor] = &quot;c3.large&quot;
knife[:chef_mode] = &quot;solo&quot;
knife[:region] = ENV[&#39;EC2_REGION&#39;]</code></pre> <p>And now <code>server create</code> command has a different look:</p> <pre><code>$ AWS_ACCESS_KEY_ID=aws-access-key-id AWS_SECRET_ACCESS_KEY=aws-secret-access-key knife ec2 server create -r &quot;role[webserver]&quot; -G www,default -x ubuntu -N server01</code></pre> <p>The <code>server list</code> argument is used to find instances that are associated with a Amazon EC2 account. The results may show instances that are not currently managed by the Chef server.</p> <pre><code>$ AWS_ACCESS_KEY_ID=aws-access-key-id AWS_SECRET_ACCESS_KEY=aws-secret-access-key knife ec2 server list
Instance ID  Name                     Public IP       Private IP      Flavor     Image         SSH Key       Security Groups  IAM Profile  State
i-xxx   staging-fix                   25.196.195.41   11.31.53.118    m1.medium  ami-f62cdf9e  some_key      db,web                        running
i-xxx   Staging::Web                                                  m1.medium  ami-3d4ff254  some_key      web                           stopped</code></pre> <p>The <code>server delete</code> argument is used to delete one or more nodes that are running in the Amazon EC2 cloud. To find a specific cloud instance, use the <code>knife ec2 server list</code> argument. Use the <code>--purge</code> option to delete all associated node and client objects from the Chef server or use the <code>knife node delete</code> and <code>knife client delete</code> sub-commands to delete specific node and client objects.</p> <pre><code>$ AWS_ACCESS_KEY_ID=aws-access-key-id AWS_SECRET_ACCESS_KEY=aws-secret-access-key knife ec2 server delete i-xxx</code></pre> <p>As you can see in these examples knife plugins simplify working with hosting cloud providers.</p> <h2 id="sec:tat-chef-metal">Chef Metal</h2> <p><a href="https://github.com/opscode/chef-metal">Chef Metal</a> solves the problem of repeatably creating machines and infrastructures in Chef. It has a plugin model that lets you write bootstrappers for your favorite infrastructures, including VirtualBox, EC2, LXC, bare metal, and many more. Combined with the power of Chef, Metal’s <code>machine</code> resource helps you to describe, version, deploy and manage everything from simple to complex clusters with a common set of tools.</p> <h3 id=examples-1>Examples</h3> <p>First of all, we should create file structure of project:</p> <pre><code>$ tree -R -a .
.
|--.chef
|.. -- knife.rb
|--.ruby-version
|-- Berksfile
|-- Berksfile.lock
|-- cluster.rb
|-- Gemfile
|-- Gemfile.lock
|-- destroy_all.rb
 -- vagrant.rb</code></pre> <p>File <code>knife.rb</code> contain setting for knife client:</p> <pre><code># This file exists mainly to ensure we don&#39;t pick up knife.rb from anywhere else
local_mode true
config_dir &quot;#{File.expand_path(&#39;..&#39;, __FILE__)}/&quot; # Wherefore art config_dir, chef?

# Chef 11.14 binds to &quot;localhost&quot;, which interferes with port forwarding on IPv6 machines for some reason
begin
  chef_zero.host &#39;127.0.0.1&#39;
rescue
end</code></pre> <p>Chef Metal uses Chef Zero to create cluster of nodes.</p> <p>Next we should install chef-zero rubygem. Also we should select which provisioner we will use. For our example we will use Vagrant, what is why we need install also chef-metal-vagrant rubygem. In this example uses bundler to install all rubygems. This is content of Gemfile file:</p> <pre><code>source &quot;http://rubygems.org&quot;

gem &#39;chef-metal&#39;
gem &#39;chef-metal-vagrant&#39;</code></pre> <p>And run <code>bundle</code> command in terminal to install all rubygems.</p> <p>In this example uses berkshelf to get all needed cookbooks. Content of Berksfile file:</p> <pre><code>source &quot;http://api.berkshelf.com&quot;

cookbook &#39;apache2&#39;
cookbook &#39;mysql&#39;</code></pre> <p>And run <code>berks install &amp;&amp; berks vendor cookbooks</code> command in terminal to install and put all cookbooks to cookbooks directory.</p> <p>All configuration will contains in files <code>vagrant.rb</code> (file contain configuration for provisioner):</p> <pre><code>require &#39;chef_metal_vagrant&#39;

vagrant_box &#39;precise64&#39; do
  url &#39;http://files.vagrantup.com/precise64.box&#39;
end

with_machine_options :vagrant_options =&gt; {
  &#39;vm.box&#39; =&gt; &#39;precise64&#39;
}</code></pre> <p>and <code>cluster.rb</code> (file contain configuration for our cluster):</p> <pre><code>require &#39;chef_metal&#39;

WEB_NODES = 2

1.upto(WEB_NODES) do |i|
  machine &quot;web#{i}&quot; do
    tag &#39;web&#39;
    recipe &#39;apache2&#39;
    converge true
  end
end

machine &#39;db&#39; do
  tag &#39;db&#39;
  recipe &#39;mysql::server&#39;
  converge true
end</code></pre> <p>By this setting we will create two web nodes and one database node. Now we are ready to create our cluster of nodes:</p> <pre><code>$ chef-client -z vagrant.rb cluster.rb
Starting Chef Client, version 11.14.2
resolving cookbooks for run list: []
Synchronizing Cookbooks:
Compiling Cookbooks...
[2014-08-02T21:22:49+03:00] WARN: Node alexeys-mbp-2 has an empty run list.
Converging 2 resources
Recipe: @recipe_files::/Users/leo/Downloads/chef-metal/vagrant.rb
  * vagrant_box[precise64] action create (up to date)
Recipe: @recipe_files::/Users/leo/Downloads/chef-metal/cluster.rb
  * machine_batch[default] action converge

...

Running handlers complete
Chef Client finished, 0/18 resources updated in 46.728927972 seconds</code></pre> <p>If you need more web nodes you just need increase <code>WEB_NODES</code> variable and run Chef Metal again.</p> <p>To cleanup all nodes I created <code>destroy_all.rb</code> file:</p> <pre><code>require &#39;chef_metal&#39;

machine_batch do
  machines search(:node, &#39;*:*&#39;).map { |n| n.name }
  action :destroy
end</code></pre> <p>As a result you should see this output:</p> <pre><code>$ chef-client -z destroy_all.rb
Starting Chef Client, version 11.14.2
resolving cookbooks for run list: []
Synchronizing Cookbooks:
Compiling Cookbooks...
[2014-08-02T21:46:26+03:00] WARN: Node alexeys-mbp-2 has an empty run list.
Converging 1 resources
Recipe: @recipe_files::/Users/leo/Downloads/chef-metal/destroy_all.rb
  * machine_batch[default] action destroy
    - run vagrant destroy -f db web1 web2 (status was &#39;running, running, running&#39;)
    - delete node db at http://127.0.0.1:8889
    - delete client db at http://127.0.0.1:8889
    - delete file /Users/leo/Downloads/chef-metal/.chef/vms/db.vm
    - delete node web1 at http://127.0.0.1:8889
    - delete client web1 at http://127.0.0.1:8889
    - delete file /Users/leo/Downloads/chef-metal/.chef/vms/web1.vm
    - delete node web2 at http://127.0.0.1:8889
    - delete client web2 at http://127.0.0.1:8889
    - delete file /Users/leo/Downloads/chef-metal/.chef/vms/web2.vm

Running handlers:
Running handlers complete
Chef Client finished, 1/1 resources updated in 32.419881 seconds</code></pre> <p>As a result, we have DSL to describe our infrastructure (this is more «visible» for DevOps engineers) and can be used to describe, version, deploy and manage everything from simple to complex clusters with a common set of tools. Also Chef Metal is working on top of Chef, so it is very simple to extend and modify your cluster configuration.</p> <h2 id="sec:tat-chef-sugar">Chef Sugar</h2> <p>Chef Sugar is a rubygem and Chef recipe that includes series of helpful sugar of the Chef core and other resources to make a cleaner, more lean recipe DSL, enforce DRY principles, and make writing Chef recipes an awesome experience. This is very useful library, which have huge amount of helpers and help for developers to not «reinvent the wheel» inside own cookbooks.</p> <h3 id=usage>Usage</h3> <p>First of all, you should add Chef Sugar inside own cookbook metadata.rb file as dependency:</p> <pre><code>depends &#39;chef-sugar&#39;</code></pre> <p>In order to use Chef Sugar in your Chef Recipes, you’ll first need to include it:</p> <pre><code>include_recipe &#39;chef-sugar&#39;</code></pre> <p>Alternatively you can put it in a base role or recipe and it will be included subsequently.</p> <p>Requiring the Chef Sugar Gem will automatically extend the Recipe DSL, <code>Chef::Resource</code> and <code>Chef::Provider</code> with helpful convenience methods. If you are working outside of the Recipe DSL, you can use the module methods instead of the Recipe DSL. In general, the module methods have the same name as their Recipe DSL counterparts, but require the node object as a parameter. For example:</p> <p>In recipe:</p> <pre><code># cookbook/recipes/default.rb
do_something if windows?</code></pre> <p>In a library as a singleton:</p> <pre><code># cookbook/libraries/default.rb
def only_on_windows(&amp;block)
  yield if Chef::Sugar::PlatformFamily.windows?(@node)
end</code></pre> <p>In a library as a mixin:</p> <pre><code># cookbook/libraries/default.rb
include Chef::Sugar::PlatformFamily

def only_on_windows(&amp;block)
  yield if windows?(@node)
end</code></pre> <p>Chef Sugar have huge amount of helper methods, more information about its you can found in <a href="https://github.com/sethvargo/chef-sugar#api">README</a>. Examples:</p> <pre><code>execute &#39;build[my binary]&#39; do
  command &#39;...&#39;
  not_if  { _64_bit? } # check system 64 bit
end</code></pre> <pre><code>if ubuntu? # system is ubuntu
  execute &#39;apt-get update&#39;
end</code></pre> <pre><code>if includes_recipe?(&#39;apache2::default&#39;) # determines if the current run context includes the recipe
  apache_module &#39;my_module&#39; do
    # ...
  end
end</code></pre> <h2 id=summary-6>Summary</h2> <p>Chef is very flexible DevOps tool. For it exists huge amount good vendor cookbooks, libraries and extensions, which allow developers and administrators use it as they see own infrastructure.</p> <p><span>9</span></p> <p><em>Alexey Vasiliev aka leopard: Chef articles</em> http://leopard.in.ua/categories.html#chef-ref</p> <p><em>All about Chef ...</em> http://docs.opscode.com/</p> <p><em>Doing Wrapper Cookbooks Right</em> http://www.getchef.com/blog/2013/12/03/doing-wrapper-cookbooks-right/</p> </body> </html>